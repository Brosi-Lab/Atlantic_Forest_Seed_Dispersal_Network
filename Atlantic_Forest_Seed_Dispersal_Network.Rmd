---
title: "Consequences of losing endangered frugivores for a tropical seed dispersal network"
author: "Therese Lamperty and Berry Brosi"
date: "started 14 March 2022; most recent edits `r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: true
    code_folding: hide
    theme: cosmo
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

In this analysis, our goal was to investigate the roles of endangered frugivores in a diverse tropical forest seed dispersal network and the potential consequences of their loss for the network. 

We used a publicly available data set from Bello et al 2017. It is a collation of multiple studies over 50+ years conducted across the Atlantic Forest biome.

In our analysis, we:

1. Assessed the network degree of endangered frugivores (all frugivores at a greater risk of extinction than those in the 'Least Concern' IUCN category) compared to non-endangered frugivores (those in Least Concern category). We repeat this with frugivores with declining global populations compared to frugivores with increasing global populations.

  1.1 This was repeated at the ecoregion scale in 3 ecoregions (Cerrado, Serra do Mar, and mata caducifolia)
  
2. Simulated frugivore extinctions predicted by endangerment status and used a topolcogical co-extinction model to analyze consequences on network robustness through secondary extinctions. Further, we evaluated if the effects of removing species according to extinction risk differ from removing species in decreasing order of degree and body size, and also a random removal scenario. 

  2.1 This was repeated at the ecoregion scale
  
3. Assessed the degree to which specialist trees rely on endangered frugivores


# Package Loading and Management

## Package loading

```{r create package list, message = F, results = F, warning = F}
# Create package list

Packages <- c("tidyverse", "knitr", "car", "bipartite", "MASS", "ggplot2", "lme4", "boot", "gridExtra", "lattice", "gginnards", "viridis", "viridisLite", "raster", "sp", "rgdal", "cowplot", "AER", "pscl", "degreenet", "DHARMa", "broom.mixed", "grid", "ggpubr", "glmmTMB")

# Load packages

lapply(Packages, library, character.only = TRUE)


# Clean 

rm(Packages)
```

**Packages used:**


# Data

## Data import


* 1 data set to import (call it "master.df"):
* 'Atlantic frugivory: a plant-frugivore interaction data set for the Atlantic Forest' (Bello et al 2017)
    + https://doi.org/10.1002/ecy.1818
    + a record of 8320 frugivory interactions

* 1 data set not needed to import until later:
* In data-in, there is also a folder veg_1992_ibge - this is the geographical information used to isolate and subset the ecoregions based on the coordinates provided per observation record in the Bello et al data set
    + That data was downloaded from the Brazilian Ministry of the Environment and Instituto Brasileiro de Geografia e Estatistica (IBGE 1993).
    + https://www.ibge.gov.br/en/home-eng.html

```{r data import}
# Load Bello et al 2017 plant-frugivore interaction dataset
master.df <- read.csv("data-in/ATLANTIC_frugivory_full_og.csv")
```


## Data formatting

After initial data formatting and cleaning, there are 6 data frames used in various steps in the analysis: 

* observations (all interactions recorded, includes duplicate interactions)
* binary interaction matrix created from the observations and used in network analysis
* a data set with all metrics (e.g. degree, body mass) for every frugivore species
    + this is called frugivore metadata (I use 'md' for metadata in the code)
* a data set with all metrics (e.g. degree) for every plant species
    + aka plant metadata
* a data set with a record of each unique interaction that occurs in the network with accompanying plant and frugivore degree and frugivore IUCN status
    + aka interaction metadata
    
X 4 because analyses are repeated for the biome and 3 ecoregions

### miscellaneous data formatting

this includes:

* merge genus and species by underscore
* fix trailing spaces and typos in spp names
* add missing body mass data
* create 'lower' and 'higher' risk endangerment category for frugivores
* remove species that are data deficient or not evaluated by IUCN


```{r initial data cleaning and formatting}

# Get rid of spaces in between genus and species for frugivores and plants:

master.df$Frugivore_Species <- sub(" ", "_", master.df$Frugivore_Species)

master.df$Plant_Species <- sub(" ", "_", master.df$Plant_Species)

# Ortalis_guttata has a trailing space, get rid of it:

master.df <- master.df %>%
  mutate(Frugivore_Species = ifelse(Frugivore_Species == "Ortalis_guttata ", "Ortalis_guttata", Frugivore_Species))

# Dataset has some species without body mass data
# Based on web searches for missing body mass values, I could manually add these below:
# conopias trivirgatus flycatcher = approx. 14 g
# dermanura cinerea = 18 g
# Hsunycteris_thomasi = 15 g
# Ortalis_guttata = 400 g
# Salvator_merianae = 2500-4535 g
# Tropidurus_hispidus = 3000g
# Xenohyla_truncata = 8 g
# Xolmis_velatus = 30 g

master.df <- master.df %>%
  mutate(Frug_Body_Mass = ifelse(Frugivore_Species == "Conopias_trivirgatus", "14", Frug_Body_Mass)) %>%
  mutate(Frug_Body_Mass = ifelse(Frugivore_Species == "Dermanura_cinerea", "18", Frug_Body_Mass)) %>%
  mutate(Frug_Body_Mass = ifelse(Frugivore_Species == "Hsunycteris_thomasi", "15", Frug_Body_Mass)) %>%
  mutate(Frug_Body_Mass = ifelse(Frugivore_Species == "Ortalis_guttata", "400", Frug_Body_Mass)) %>%
  mutate(Frug_Body_Mass = ifelse(Frugivore_Species == "Salvator_merianae", "3000", Frug_Body_Mass)) %>%
  mutate(Frug_Body_Mass = ifelse(Frugivore_Species == "Tropidurus_hispidus", "3000", Frug_Body_Mass)) %>%
  mutate(Frug_Body_Mass = ifelse(Frugivore_Species == "Xenohyla_truncata", "8", Frug_Body_Mass)) %>%
  mutate(Frug_Body_Mass = ifelse(Frugivore_Species == "Xolmis_velatus", "30", Frug_Body_Mass))

# If NOT manually adding the missing body mass values by running above code w/mutate, go ahead and remove those frugivores:

# master.df <- master.df %>% filter(!is.na(Frug_Body_Mass))

# Create extra column for broader endangerment grouping: 'lower risk' or 'higher risk' designation. Anything labeled as Least Concern (LC) by IUCN = lower_risk, anything the IUCN labels as vulnerable (VU), Near Threatened (NT), Endangered (EN), or Critically Endangered (CR) = higher_risk

# Remove data deficient and not evaluated species from removal master.df and from matrix

master.df <- master.df %>%
  filter(Frug_IUCN != "DD") %>%
  filter(Frug_IUCN != "NE") %>%
  filter(!is.na(Frug_IUCN))

# Mutate abbreviated IUCN status to create 2 broad categories of higher risk and lower risk

master.df$Frug_risk_level <- master.df$Frug_IUCN # create a copied column of IUCN status to mutate

master.df <- master.df %>%
  mutate(Frug_risk_level = ifelse(Frug_risk_level == "LC", "lower_risk", "higher_risk"))

# Fix inconsistency with population trend capitalization
# Make 'Stable' populations all w/capital S:

master.df <- master.df %>%
  mutate(Frug_Population_Trend = ifelse(Frug_Population_Trend == "stable", "Stable", Frug_Population_Trend))
```

### Create the biome frugivore metadata

Just pulling out info for each species that occurs in the network and coupling it with relevant species info

```{r data formatting continued: create frugivore and plant metadata}
# just want 1 row of data per unique frugivore, and these are the columns I want:

biome_frug_md <- master.df %>%
  distinct(Frugivore_Species, .keep_all = TRUE) %>%
  dplyr::select(Frugivore_Species, Frug_Group, Frug_Body_Mass, Frug_Mean_Gape_Size, Frug_IUCN, Frug_risk_level, Frug_Population_Trend)

# also make body mass numeric

biome_frug_md$Frug_Body_Mass<-as.numeric(biome_frug_md$Frug_Body_Mass)

# plants:

biome_plant_md <- master.df %>%
  distinct(Plant_Species)

# At this point, have 3 things in env that we need: biome_frug_md, biome_plant_md, master.df
```

### Create biome interaction matrix

Make binary (0s and 1s) network from cleaned/formatted observation data frame. Also make interaction metadata to add relevant species info to later. This version of making the interaction matrix is annotated, but the process is repeated identically for each ecoregion, and that code is not annotated to reduce clutter/redundant information.

```{r data formatting continued: create interaction matrix and interaction metatdata for biome}

# create binary interaction matrix

df.EL <- master.df # copy data frame- going to make 'df.EL' into an 'edge list' (EL)

df.EL$intxn <- paste(df.EL$Frugivore_Species, df.EL$Plant_Species, sep = "//") # start making this 'edge list'- pull out pairs of interacting spp

# head(df.EL$intxn) # check it out, should have a column of each interaction name

df.EL <- df.EL %>% # The only info the edge list needs is the species and the interaction existence record
  dplyr::select(Plant_Species, Frugivore_Species, intxn)

# interaction matrix creation function (Beth Morrison), works as weighted or binary:
el.to.imat <- function(edgelist) {
  
  edgelist$intxn = paste(edgelist[ ,1], edgelist[ ,2], sep = "//") # put plants (or lower order species should be in the first column)
  
  edgelist$freq = rep(1, nrow(edgelist))
  
  edgelist.2 = aggregate(edgelist$freq, by = list(edgelist$intxn), FUN = sum)
  
  colnames(edgelist.2) = c('intxn', 'freq')
  
  edgelist.split = do.call(rbind, strsplit(edgelist.2$intxn, "//"))
  
  w.edgelist = data.frame(low.spp = edgelist.split[ ,1], high.spp = edgelist.split[ ,2], freq = edgelist.2$freq)
  
  intxn.mat = spread(w.edgelist, key = "high.spp", value = "freq")
  
  intxn.mat[is.na(intxn.mat)] = 0
  rownames(intxn.mat) = intxn.mat[ ,1]
  intxn.mat = intxn.mat[ ,-1]
  
  return(list(w.edgelist, intxn.mat)) # will return a list; first element is the weighted edge, second element is the matrix
  # sadly, we can't actually use this data as weighted
  
}

el.info <- el.to.imat(df.EL)

i.mat <- el.info[[2]] # store the interaction matrix, it's weighted right now

i.mat[i.mat > 0] <- 1 # change interaction matrix to only 1's and 0's

# head(el.info[[2]]) # make sure it looks ok

biome.mat <- i.mat # copy and rename

# make interaction metadata

biome_interaction_md <- master.df %>%
  distinct(Frugivore_Species, Plant_Species, .keep_all = TRUE)

# Clean
rm(df.EL, el.info, i.mat)

# At this point, we have 5 things in the environment that we need later: biome_interaction_md, biome_frug_md, biome_plant_md, biome.mat, master.df

```

### Compute degree for frugivore and plant species at biome scale

Use `bipartite` specieslevel function to get degree for each species and add to metadata frames

```{r compute species degrees and add to metadata}

# Compute degree for frugivores

Frugivore_degree <- specieslevel(biome.mat, level = "higher", index = "degree")

# make the rownames (which are the frugivore species) the first column 

Frugivore_degree <- Frugivore_degree %>%
  tibble::rownames_to_column("Frugivore_Species")

# rename the second column 

names(Frugivore_degree)[2] <-"Frugivore_degree"

# add the frugivore degree data to the frugivore metadata now

biome_frug_md <- merge(Frugivore_degree, biome_frug_md, by = "Frugivore_Species")

#------------------------------------------------#

# Compute degree for plants

Plant_degree <- specieslevel(biome.mat, level = "lower", index = "degree")

# convert the rows to be the first column (they are the plant species names)

Plant_degree <- Plant_degree %>%
  tibble::rownames_to_column("Plant_Species") 

# rename the second column 

names(Plant_degree)[2] <-"Plant_degree"

# add plant degree to the plant metadata

biome_plant_md <- merge(biome_plant_md, Plant_degree, by = "Plant_Species") 

#------------------------------------------------#

# add degree for plants and frugivores to the interaction metadata for later

biome_interaction_md <-merge(biome_interaction_md, Plant_degree, by = "Plant_Species")

biome_interaction_md <-merge(biome_interaction_md, Frugivore_degree, by = "Frugivore_Species")

#-------------------------------------------------#

# clean

rm(Plant_degree, Frugivore_degree)

```

### Pull out ecoregions

There are 3 regions covered by Bello et al data set that have a decent number of frugivory observations recorded: Cerrado, Serra do Mar, Mata Caducifolia.

I used shape files of Brazil's vegetation from data available online through Brazil's Ministry of the Environment to determine ecoregion geographical limits and to extract the data from Bello et al that was within each region. 

We decided it is not problematic to use this 1992 vegetation data since the Atlantic forest interaction dataset itself was recorded from the 1960's through 2016 (and the ecoregions shouldn't have changed). 

Within Bello et al's dataset, there are a LOT of studies (maybe 30%) that actually did not have lat/long coordinates for me to reference, but I do have the names of the studies from which all data came from and so I can go and look up where exactly the studies took place to appropriately assign them to a given ecoregion if we decide that's worth it.

```{r match observation coordinates with ecoregion data, message = F, results = F, warning = F}

# not all sites had geographic locations, get rid of those
df.only.with.coords = master.df %>%
  filter(!is.na(Latitude)) %>%
  filter(!is.na(Longitude)) %>%
  mutate(longlat = paste(Longitude, Latitude, sep =","))
# this just eliminated 37.5% of my observations
# now have 5115 obs

# start a new data set, just get unique lat/long coordinates, this is a unique identifier
sites = as.data.frame(levels(as.factor(df.only.with.coords$longlat)))

sites = sites %>%
  rename(longlat = names(sites)) %>%
  mutate(longlat2 = longlat) %>%
  separate(longlat, c("long", "lat"), ",") %>%
  mutate(long = as.numeric(long)) %>%
  mutate(lat = as.numeric(lat))

veg = readOGR("data-in/veg_1992_ibge/brazilveg.shp")

# creating a data frame for the spatial data (point file instead of shape file)

sites2 <- SpatialPointsDataFrame(coords = sites[,c(1,2)], data = sites,
                               proj4string = CRS("+proj=longlat +ellps=GRS67 +towgs84=0,0,0"))

# plot all points and see what vegetation looks like

# plot(sites2)

# plot(veg)

test = over(sites2,veg) # retrieve veg info for each point in sites2

# lines up with forest type column?

test = test %>%
  cbind(sites) %>%
  filter(!is.na(GID)) # gets rid of points in ocean...

data2 = df.only.with.coords %>% filter(longlat %in% test$longlat2) #also gets rid of ocean points in the original data frame

# now my data frame is down to 4308 observations

# levels(as.factor(test$TIPO))
# has all ecoregions I want

# rename w/something more descriptive
ecoregion.info <- test
df.only.with.coords<-data2

# join ecoregion.info and my parred down obs df by longlat (df.only.with.coords) and longlat2 (ecoregion.info) - should end up with a 4308 by 47 df
ecoregion.info$longlat <- ecoregion.info$longlat2
ER.df <- left_join(df.only.with.coords, ecoregion.info, "longlat")

# 13 observations in the Bello et al data have coordinates that seem incorrect - they are for points in the water. Remove those:
ER.df <- ER.df %>% filter(!is.na(TIPO))

# Clean
rm(sites, sites2, df.only.with.coords, test, data2, veg, ecoregion.info)

# We want to keep ER.df (ecoregion dataframe) in the environment for next few steps
```

### Summarize the extent to which networks per ecoregion have been sampled

How many observations do we have per ecoregion ('TIPO')?

```{r summarize extent to which networks per ecoregion have been sampled}
ER.df %>%
  group_by(TIPO) %>%
  summarise(n())
```

Atividades Agricolas we've decided is a broad category of disturbed/secondary/agricultural areas, and although there is a large number of observations from regions fitting that description, it is not a single ecoregion with biological significance relevant to our study, so we are not going to use that as an 'ecoregion'.
    * For most sampled, these are the top 3, which we will use: Cerrado, Serra do Mar, Mata Caducifolia.

### Isolate the ecoregions with best coverage

To double check, I also looked over what the TIPOS correspond to (Google Earth, image and lit search, etc). 

Floresta Atlantica --> coastal forest (Serra do Mar)
Cerrado --> tropical savanna
Mata Caducifolia --> deciduous tropical forest

```{r subset ecoregions}

# Cerrado

cerrado.df <- ER.df %>%
  filter(TIPO == "Cerrado")

#---------------------------------------------------#

# Serra do Mar

serra.do.mar.df <- ER.df %>%
  filter(TIPO == "Floresta Atlantica")

serra.do.mar.df <- serra.do.mar.df %>%
  mutate(TIPO == ifelse(TIPO == "Floresta Atlantica", "Serra do Mar", TIPO)) # rename the 'Floresta Atlantica' Serra do Mar, which is what this area is broadly called ('coastal forest)

#---------------------------------------------------#

# Mata Caducifolia

mata.caducifolia.df <- ER.df %>%
  filter(TIPO == "Mata Caducifolia")

rm(ER.df)

```

### Create ecoregion frugivore metadata

This is a repeat of what was done above with the biome-scale data. I am sub-setting the data from each ecoregion to get metadata for each frugivore and plant species in a given ecoregion network. 

```{r make frugivore and plant metadata for ecoregions}

# Frugivore metadata creation per ecoregion:

cerrado_frug_md <- cerrado.df %>%
  distinct(Frugivore_Species, .keep_all = TRUE)

serra.do.mar_frug_md <- serra.do.mar.df %>%
  distinct(Frugivore_Species, .keep_all = TRUE)

mata.caducifolia_frug_md <- mata.caducifolia.df %>%
  distinct(Frugivore_Species, .keep_all = TRUE)

#---------------------------------------------------#

# Plant metadata creation per ecoregion:

cerrado_plant_md <- cerrado.df %>%
  distinct(Plant_Species, .keep_all = TRUE)

serra.do.mar_plant_md <- serra.do.mar.df %>%
  distinct(Plant_Species, .keep_all = TRUE)

mata.caducifolia_plant_md <- mata.caducifolia.df %>%
  distinct(Plant_Species, .keep_all = TRUE)

```

### Create ecoregion interaction matrices and interaction metadata

Also a repeat of what was done with the biome-scale data, I am creating binary interaction matrices for each ecoregion. See this process for the biome-scale network above for annotated code. 

```{r make interaction matrices for each ecoregion}

# Cerrado

df.EL <- cerrado.df

df.EL$intxn <- paste(df.EL$Frugivore_Species, df.EL$Plant_Species, sep = "//") 

df.EL <- df.EL %>%
  dplyr::select(Plant_Species, Frugivore_Species, intxn)

el.info <- el.to.imat(df.EL)

i.mat <- el.info[[2]]

i.mat[i.mat > 0] <- 1 

mat.cerrado <- i.mat 

interaction_md.CR <- unique(df.EL[c("Frugivore_Species","Plant_Species")])

#------------------------------------------------#

# Serra do Mar

df.EL <- serra.do.mar.df

df.EL$intxn <- paste(df.EL$Frugivore_Species, df.EL$Plant_Species, sep = "//") 

df.EL <- df.EL %>% 
  dplyr::select(Plant_Species, Frugivore_Species, intxn)

el.info <- el.to.imat(df.EL)

i.mat <- el.info[[2]] 

i.mat[i.mat > 0] <- 1 

mat.serra.do.mar <- i.mat 

interaction_md.SM <- unique(df.EL[c("Frugivore_Species","Plant_Species")])

#------------------------------------------------#

# Mata Caducifolia

df.EL <- mata.caducifolia.df

df.EL$intxn <- paste(df.EL$Frugivore_Species, df.EL$Plant_Species, sep = "//") 

df.EL <- df.EL %>% 
  dplyr::select(Plant_Species, Frugivore_Species, intxn)

el.info <- el.to.imat(df.EL)

i.mat <- el.info[[2]] 

i.mat[i.mat > 0] <- 1 

mat.mata.caducifolia <- i.mat

interaction_md.MC <- unique(df.EL[c("Frugivore_Species","Plant_Species")])

# Clean
rm(i.mat, el.info, el.to.imat, df.EL)

```

### Compute degree for frugivores and plants and make plant and frugivore metadata at ecoregion scale

As done with biome-scale network above, compute frugivore and plant species' degrees within each ecoregion's network and add to metadata.

```{r compute frugivore and plant network degrees within each ecoregions network}

# Compute frugivore degree for the ecoregions:

# cerrado

Frugivore_degree.CR <- specieslevel(mat.cerrado, level = "higher", index = "degree")

#---------------------------------------------------#

# Serra do Mar

Frugivore_degree.SM <- specieslevel(mat.serra.do.mar, level = "higher", index = "degree")

#---------------------------------------------------#

# Mata caducifolia

Frugivore_degree.MC <- specieslevel(mat.mata.caducifolia, level = "higher", index = "degree")

#----------------------------------------------------------------#

# Add frugivore degree to frugivore metadata:

# cerrado, make the row names (which are the frugivore species) into the first column 

Frugivore_degree.CR <- Frugivore_degree.CR %>%
  tibble::rownames_to_column("Frugivore_Species") 

# and name the second column frugivore degree

names(Frugivore_degree.CR)[2] <- "Frugivore_degree" 

# now join the frugivore degree data to the frugivore metadata 

cerrado_frug_md <- merge(Frugivore_degree.CR, cerrado_frug_md, 
                        by = "Frugivore_Species") 

#---------------------------------------------------#

# Serra do Mar

Frugivore_degree.SM <- Frugivore_degree.SM %>%
  tibble::rownames_to_column("Frugivore_Species") 

names(Frugivore_degree.SM)[2] <-"Frugivore_degree"

# add frugivore degree to seraa do mar frugivore metadata

serra.do.mar_frug_md <- merge(Frugivore_degree.SM, serra.do.mar_frug_md, 
                              by = "Frugivore_Species") 

#---------------------------------------------------#

# Mata caducifolia

Frugivore_degree.MC <- Frugivore_degree.MC %>%
  tibble::rownames_to_column("Frugivore_Species")

names(Frugivore_degree.MC)[2] <- "Frugivore_degree" 

# add frugivore degree to mata caducifolia frugivore metadata

mata.caducifolia_frug_md <- merge(Frugivore_degree.MC, mata.caducifolia_frug_md, 
                                 by = "Frugivore_Species") 

#-----------------------------------------------------------------#

# Compute plant degree for the ecoregions & add the to plant metadata:

# cerrado

Plant_degree.CR <- specieslevel(mat.cerrado, level = "lower", index = "degree")

Plant_degree.CR <- Plant_degree.CR %>%
  tibble::rownames_to_column("Plant_Species")

names(Plant_degree.CR)[2] <- "Plant_degree"

# add cerrado plant degree to cerrado plant meta data 

cerrado_plant_md <- merge(cerrado_plant_md, Plant_degree.CR, 
                          by = "Plant_Species")

#---------------------------------------------------#

# Mata caducifolia

Plant_degree.MC <- specieslevel(mat.mata.caducifolia, level = "lower", 
                                index = "degree")

Plant_degree.MC <- Plant_degree.MC %>%
  tibble::rownames_to_column("Plant_Species") 

names(Plant_degree.MC)[2] <- "Plant_degree"

# add mata caducifolia plant degree to plant metadata 

mata.caducifolia_plant_md <- merge(mata.caducifolia_plant_md, Plant_degree.MC,
                                   by = "Plant_Species") 

#---------------------------------------------------#

# Serra do Mar

Plant_degree.SM <- specieslevel(mat.serra.do.mar, level = "lower", index = "degree")

Plant_degree.SM <- Plant_degree.SM %>%
  tibble::rownames_to_column("Plant_Species") 

names(Plant_degree.SM)[2] <- "Plant_degree" 

# add serra do mar plant degree to plant md

serra.do.mar_plant_md <- merge(serra.do.mar_plant_md, Plant_degree.SM, 
                               by = "Plant_Species") 

#-----------------------------------------------------------------#

# Also add degree for plants and frugivores to the dataframe with each unique interaction from the network for later analysis and finish compiling the interaction metadata info by adding the endangerment data for frugivores

# cerrado

interaction_md.CR <- merge(interaction_md.CR, Plant_degree.CR, by = "Plant_Species")

interaction_md.CR <- merge(interaction_md.CR, Frugivore_degree.CR, 
                          by = "Frugivore_Species")

temp <- cerrado_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, Frug_IUCN)

interaction_md.CR <- merge(interaction_md.CR, temp, by = "Frugivore_Species")

#---------------------------------------------------#

# Mata Caducifolia

interaction_md.MC <- merge(interaction_md.MC, Plant_degree.MC, by = "Plant_Species")

interaction_md.MC <- merge(interaction_md.MC, Frugivore_degree.MC, 
                          by = "Frugivore_Species")

temp <- mata.caducifolia_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, Frug_IUCN)

interaction_md.MC <- merge(interaction_md.MC, temp, by = "Frugivore_Species")

#---------------------------------------------------#

# Serra do Mar

interaction_md.SM <- merge(interaction_md.SM, Plant_degree.SM, by = "Plant_Species")

interaction_md.SM <- merge(interaction_md.SM, Frugivore_degree.SM, 
                          by = "Frugivore_Species")

temp<-serra.do.mar_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, Frug_IUCN)

interaction_md.SM <- merge(interaction_md.SM, temp, by = "Frugivore_Species")

#---------------------------------------------------#

# clean

rm(temp, Frugivore_degree.CR, Frugivore_degree.SM, Frugivore_degree.MC, Plant_degree.CR, Plant_degree.SM, Plant_degree.MC)

```


# Analysis 

* Analysis 1 evaluates relationships between frugivore degree and endangerment status
    + Done first at the biome level, then repeated for each of the ecoregion-scale networks
* Analysis 2 evaluates relationships between frugivore degree and population trend
    + Done first at the biome leve, then repeated for each of the four ecoregions
    + Population trends change before endangerment status does, so it is worthwhile evaluating in addition to just species currently classified as endangered by IUCN
    + Both types of analyses (looking at both IUCN status and population trends as predictors of frugivore network degree) use negative binomial glms
* Analysis 3 uses 'for loops' to simulate different frugivore loss scenarios
    + The scenarios are: decreasing order of IUCN status, body mass, and network degree; plus a random removal scenario
    + This is done for the biome-scale network and for each of the ecoregions
    + Bootstrapping is used to gain estimates and 95% confidence intervals (CI) following the IUCN-status-based and random loss simulations.
* Analysis 4 evaluates relationships between specialist trees and endangered frugivores
    + This is done by summarizing the data looking at how many trees with degrees 1-5 (spanning trees that are extreme specialists according to the dataset and those that are relatively highly specialized) rely on endangered frugivore partners


## Analysis 1: evaluating relationships between frugivore degree and endangerment status

* Negative binomial model evaluating effect of 'higher_risk' versus 'lower_risk' endangerment status of frugivores on their degree: are these two things related?
    + This is only done at the biome scale because the ecoregions have too small of sample sizes
    + Using negative binomial to account for overdispersion
    + To meet model assumptions, we subtract 1 from all degree values so that the count data includes zeros and is able to be modeled with our neg binomial approach
    
### data overview: looking at the degree data for lower and higher risk frugivores

#### biome-scale - frugivore degree for lower vs higher risk species

__Frugivore degree distribution for the biome-scale network:__

```{r biome frugivore degree histogram, fig.width = 4, fig.height=4}

hist(biome_frug_md$Frugivore_degree, breaks = 20, main = "Biome\n frugivore degrees", xlab = NULL)

```

  There are a lot of singletons and a few frugivores with degree > 50 but it drops off fast.

__Mean degree for frugivores in 'lower risk' category:__
```{r biome frugivore mean degree lower risk}

mean(biome_frug_md$Frugivore_degree[which(biome_frug_md$Frug_risk_level == "lower_risk")])

```
__Mean degree for frugivores in 'higher risk' category:__
```{r biome frugivore mean degree higher risk}

mean(biome_frug_md$Frugivore_degree[which(biome_frug_md$Frug_risk_level == "higher_risk")])

```
__What do the two groups' histograms look like?__

```{r histograms for low and high risk frugivore degrees, warning=F}

par(mfrow=c(1,2))

hist(biome_frug_md$Frugivore_degree[which(biome_frug_md$Frug_risk_level == "lower_risk")], breaks =20, main = "Biome\n frugivore degrees: low risk", xlab = NULL)

hist(biome_frug_md$Frugivore_degree[which(biome_frug_md$Frug_risk_level == "higher_risk")], breaks = 20, main = "Biome\n frugivore degrees: high risk", xlab = NULL)

```

  Definitely a lot more frugivores exist in the 'low risk' category. Lots of singletons in both groups. In high risk, see a bit of a more clumpy distribution and a bump around degree = 50, whereas lower risk category has a smoother tail with greater frequency of frugivores that disperse between 1-30 species. 

#### ecoregion-scale - degree for lower vs higher risk species

This is all a repeat of what was examined above for the biome-scale, but now at smaller regional-scale networks to check for pattern consistency. 

__First, look at frugivore degree distribution for the ecoregion-scale networks:__
```{r ecoregion frugivore degree histogram}

par(mfrow=c(2,2))

hist(cerrado_frug_md$Frugivore_degree, breaks =20, main = "Cerrado\n frugivore degrees", xlab = NULL) 

#cerrado really seems to have frugs with fewer interactions

hist(serra.do.mar_frug_md$Frugivore_degree, breaks =20, main = "Serra do Mar\n frugivore degrees", xlab = NULL)

hist(mata.caducifolia_frug_md$Frugivore_degree, breaks =20, main = "Mata caducifolia\n frugivore degrees", xlab = NULL) #kind of more like cerrado
```

  Similar to the biome-scale degree distributions. Noting that the cerrado has a more limited range of frugivore degree values than the other two ecoregions, but it is also the smallest of the 3 regional networks so that likely play a part in that difference.

__What are the mean degrees per risk category per ecoregion?__
```{r summarize degree mean per ecoregion per risk level, message=FALSE}
# I'm going to make a temporary dataframe that I will use later in graphing
# and it will have ecoregion information combined

cerrado_frug_md$ecoregion <- "cerrado" # add ecoregion column to each

serra.do.mar_frug_md$ecoregion <- "serra.do.mar"

mata.caducifolia_frug_md$ecoregion <- "mata.caducifolia"

# subset the columns I will want for summarizing and for plotting later:

# cerrado

eco_temp.cer <- cerrado_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, 
                Frug_Population_Trend, Frugivore_degree, ecoregion) 

# serra do mar

eco_temp.ser <- serra.do.mar_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, 
                 Frug_Population_Trend, Frugivore_degree, ecoregion)

# mata caducifolia

eco_temp.mata <- mata.caducifolia_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, 
                 Frug_Population_Trend, Frugivore_degree, ecoregion)

eco_temp <- rbind(eco_temp.cer, eco_temp.ser, eco_temp.mata) # combine

# summarize - see means per group

eco_means_risk <- eco_temp %>% # group by ecoregion and risk level, get me avgs
  group_by(ecoregion, Frug_risk_level) %>%
  summarise(mean(Frugivore_degree)) 

names(eco_means_risk)[3] <- "mean" # name the column, will use this later in plots

eco_means_risk

```

  Qualitatively, the higher risk frugivores also have higher mean degrees (e.g. they disperse more species of plants, on average, compared to lower risk ones). But it's important to remember here that some of the higher risk categories at the regional scale are pretty small - I think there are only 3 'high risk' frugivores in Cerrado network, for example. 


__As done with the biome-scale data, visually look at and compare histograms for frugivore degrees between the two groups for each ecoregion to get an idea of how data is distributed:__

```{r histograms each category each ecoregion}

par(mfrow = c(3,2))

# cerrado, low risk

hist(cerrado_frug_md$Frugivore_degree[which(cerrado_frug_md$Frug_risk_level == "lower_risk")], 
     breaks = 20,  
     main = "Cerrado degrees\n low risk frugs", xlab = NULL)

# cerrado, high risk (all 3 of them..)

hist(cerrado_frug_md$Frugivore_degree[which(cerrado_frug_md$Frug_risk_level == "higher_risk")],
     breaks = 20,
     main = "Cerrado degrees\n high risk frugs", xlab = NULL)

# serra do mar, low risk

hist(serra.do.mar_frug_md$Frugivore_degree[which(serra.do.mar_frug_md$Frug_risk_level == "lower_risk")], 
     breaks = 20, 
     main = "Serra do Mar degrees\n low risk frugs", xlab = NULL)

# serra do mar, high risk

hist(serra.do.mar_frug_md$Frugivore_degree[which(serra.do.mar_frug_md$Frug_risk_level == "higher_risk")], 
     breaks = 20, 
     main = "Serra do Mar degrees\n high risk frugs", xlab = NULL)

# serra do mar, low risk

hist(mata.caducifolia_frug_md$Frugivore_degree[which(mata.caducifolia_frug_md$Frug_risk_level == "lower_risk")], 
     breaks = 20, 
     main = "Mata caducifolia degrees\n low risk frugs", xlab = NULL)

# serra do mar, high risk

hist(mata.caducifolia_frug_md$Frugivore_degree[which(mata.caducifolia_frug_md$Frug_risk_level == "higher_risk")], 
     breaks = 20, 
     main = "Mata caducifolia degrees\n high risk frugs", xlab = NULL)

```

  Nothing crazy or surprising here; we can see though with cerrado that of those 3 frugivores, one has relatively high degree while other two aren't remarkable (that pulled the mean up for that group obviously). Mata Caducifolia also is kinda split between a few high risk frugivores with relatively high degree for the region, but a larger portion are unremarkable.  


__Number of frugivore species in higher versus lower risk groups: biome-scale__
```{r summarise how many species in each endangerment category at biome level, message=FALSE}

biome_frug_md %>% group_by(Frug_risk_level) %>%
  summarise(count = length(Frugivore_Species))

```

  ~14% of frugivores in the network are in the higher risk category.

__Number of frugivore species in higher versus lower risk groups: ecoregion-scale__
```{r number of species per risk level per ecoregion}
eco_temp %>% # group by ecoregion and risk level, get me avgs
  group_by(ecoregion, Frug_risk_level) %>%
  summarise(length(Frugivore_Species)) 

names(eco_means_risk)[3] <- "count" # name the column

```

### Analysis 1: Negative binomial model examining relationship between frugivore risk level and degree

```{r analysis 1 component 1}

# our data is 'underdispersed' and fails the negative binomial model assumptions
# to remedy this, we create a separate column for frugivore degree and subtract 1 from all values

biome_frug_md$subzero <- (biome_frug_md$Frugivore_degree) - 1 # transform degree data by subtracting 1 from all values

# negative binomial model

biome.deg.m1 <- glm.nb(subzero ~ Frug_risk_level, data = biome_frug_md)

summary(biome.deg.m1) # look at output

aov.biome.deg.m1 = Anova(biome.deg.m1) # simplify model results

aov.biome.deg.m1 # display simplified results


# clean

rm(aov.biome.deg.m1, out.aov.biome.deg.m1)

```

__* Summary__
    + There is a non-significant trend of frugivores in the 'higher risk' category to have higher network degree values (diet breadths) than frugivores in the IUCN least concern category (Chisq = 1.86, p = 0.17)



### Analysis 1 model validation
```{r model validation analysis 1}

sim.out.biome.deg.m1 <- simulateResiduals(fittedModel = biome.deg.m1, plot = F)

plot(sim.out.biome.deg.m1) # plot residual plots

testDispersion(sim.out.biome.deg.m1, plot = F) # print dispersion results

testZeroInflation(sim.out.biome.deg.m1, plot = F) # print zero-inflation results

# clean

rm(biome.deg.m1, sim.out.biome.deg.m1)

```


__* Summary: The negative binomial model with the transformation of degree - 1 fits model assumptions.__


### Analysis 1: biome-scale analysis of frugivore degrees for higher and lower endangerment risk

* Negative binomial model output included in the following plot of frugivore network degree at the biome-scale, split into frugivores in the higher risk (NT, VU, EN, CR) and lower risk (LC) IUCN categories
    + the mean values are added as black triangles
    + 95% confidence intervals (CIs) with 1000 bootstraps and shown as bars around means

```{r get confidence intervals of mean degree per risk level at biome scale for fig 2a, cache=TRUE}

# Get plot data ready (compute 95% CIs)

# Higher risk = HR, lower risk = LR

# Bootstrap using negative binomial specific function (package degreenet)

# HR

biome_bootstrap.HR <- 
  bootstrapnb(biome_frug_md$Frugivore_degree
              [which(biome_frug_md$Frug_risk_level == "higher_risk")], 
              m = 1000, alpha = 0.95)

# LR

biome_bootstrap.LR <- 
  bootstrapnb(biome_frug_md$Frugivore_degree
              [which(biome_frug_md$Frug_risk_level == "lower_risk")], 
              m = 1000, alpha = 0.95)


# make a dataframe and put the CIs in there for graphing 

biome_bootstrap.temp1 <- data.frame(matrix(vector(),1, 5, dimnames=list(c(), c("Region", "Frug_risk_level", "mean", "lower.95", "upper.95"))))

biome_bootstrap.temp1[1] <- "Atlantic_Forest"

biome_bootstrap.temp1[2] <-"higher_risk"

biome_bootstrap.temp1[3] <- mean(biome_frug_md$Frugivore_degree
                                 [which(biome_frug_md$Frug_risk_level == "higher_risk")])

biome_bootstrap.temp1[4] <- biome_bootstrap.HR[[1]] 

biome_bootstrap.temp1[5] <- biome_bootstrap.HR[[5]]

biome_bootstrap.temp1[2,1] <- "Atlantic_Forest"

biome_bootstrap.temp1[2,2] <-"lower_risk"

biome_bootstrap.temp1[2,3] <- mean(biome_frug_md$Frugivore_degree[
  which(biome_frug_md$Frug_risk_level == "lower_risk")])

biome_bootstrap.temp1[2,4] <- biome_bootstrap.LR[[1]] 

biome_bootstrap.temp1[2,5] <- biome_bootstrap.LR[[5]]

```

Above code computes bootstrapped 95% confidence intervals after 1000 iterations.

```{r version 1 of fig 2a biome scale degree vs endangerment level, eval=FALSE, warning=FALSE}

biome_deg.risk.level.plot <- biome_frug_md %>%
  
ggplot(aes(x = Frug_risk_level, y = Frugivore_degree, color = Frug_risk_level)) +
  
  geom_point(size = 2, shape = 16, alpha = 0.7,
             position=position_jitterdodge(jitter.width = 0.15)) + # plot each frugivore's degree as jitter/dodged points that are slightly translucent
  
  geom_pointrange(data = biome_bootstrap.temp1, 
                  mapping = aes(x = Frug_risk_level, 
                                y = mean, ymax = upper.95, ymin = lower.95, 
                                color = "black"), size = 0.4, shape = 17) + # add a point to show the means for each risk category and include CIs
  
  theme_bw() + labs(y="Trees dispersed", x = NULL) + # theme and add label
  
  theme(axis.text=element_text(colour="black", size = 8)) + # make axis text bigger and black
  
  theme(axis.title = element_text(size = 10)) + #make axis title bigger and bold
  
  scale_x_discrete(labels = c("Higher risk", "Lower risk")) + # add x labels
  
  scale_colour_manual(labels = c("Group mean", "Higher risk", "Lower risk"), 
                      values = c("black","darkred", "darkgoldenrod1")) + # specify colors manually
  
  theme(legend.title=element_blank()) + # remove legend
  
  annotate(geom="text", size = 3.25, x = 1.5, y = 128, 
           label = bquote(~italic(X^2)~'= 1.30,' ~italic(p)~ '= 0.25')) + # add model output
  
  ggtitle("Biome\n\nFrugivore diet breadth:\nhigh versus low endangerment status") +
  
  theme(plot.title = element_text(size = 10)) + # add an overall title 
  
  theme(plot.title=element_text(hjust = 0.5)) + # adjust where the title shows up
  
  theme(legend.position = "none") + # no legend
  
  labs(tag = "(a)") # add the alphabetical tag

biome_deg.risk.level.plot # display plot

# clean

# rm(biome_bootstrap.HR, biome_bootstrap.LR, biome_bootstrap.temp1)

```

Code for first version of fig 2a using jittered points to show frugivore degree data in each high and low risk categories at the whole biome scale.

```{r version 2 fig 2a revised biome scale degree vs endangerment level as violin plot, warning=FALSE}

biome_deg.risk.level.vplot <- biome_frug_md %>%
  
ggplot(aes(x = Frug_risk_level, y = Frugivore_degree, fill = Frug_risk_level, group = Frug_risk_level)) +
  geom_violin(trim = FALSE, alpha = 0.80) + # use violin plot to show data distribution
  
  theme_bw() + labs(y="Trees dispersed", x = NULL) + # theme and add label
  
  theme(axis.text=element_text(colour="black", size = 8)) + # make axis text bigger and black
  
  theme(axis.title = element_text(size = 10)) + #make axis title bigger and bold
  
  scale_x_discrete(labels = c("Higher risk", "Lower risk")) + # add x labels
  
  scale_fill_manual(labels = c("Group mean", "Higher risk", "Lower risk"), 
                      values = c("firebrick4", "goldenrod3")) + # specify colors manually
  
    geom_pointrange(data = biome_bootstrap.temp1, # add a point to show the bootstrapped mean and 95% confidence intervals
                  mapping = aes(x = Frug_risk_level, 
                                y = mean, ymax = upper.95, 
                                ymin = lower.95), 
                  color = "black", size = 0.75, shape = 16) +
  
  theme(legend.title=element_blank()) + # remove legend
  
  annotate(geom="text", size = 3.25, x = 1.5, y = 128, 
           label = bquote(~italic(X^2)~'= 1.30,' ~italic(p)~ '= 0.25')) + # add model output
  
  ggtitle("Biome\n\nFrugivore diet breadth:\nhigh versus low endangerment status") +
  
  theme(plot.title = element_text(size = 10)) + # add an overall title 
  
  theme(plot.title=element_text(hjust = 0.5)) + # adjust where the title shows up
  
  theme(legend.position = "none") + # no legend
  
  labs(tag = "(a)") # add the alphabetical tag


biome_deg.risk.level.vplot # display plot

```

This violin plot shows degree of frugivores in the higher risk (NT, VU, EN, CR) and lower risk (LC) IUCN categories across the whole Atlantic Forest biome. Bars show 95% CIs around the mean (which is shown as black triangle for each group), calculated from 1000 bootstrap iterations.

## Analysis 2: evaluating relationships between frugivore degree and population trends

The steps in this analysis are a repeat of the analysis above that compared frugivore degree at the biome scale between frugivores at higher versus lower risk of extinction. Here, however, we are looking at frugivores belonging to growing versus shrinking global populations as these population trends are early indicators of future endangerment/extinction risk.

### data overview: looking at the degree data in the increasing and decreasing population groups

#### Biome-scale: network degree in the increasing population grouper and higher risk frugivore groups

__Mean degree for frugivores in with increasing population sizes:___

```{r biome mean degree of frugivores with growing pops}

mean(biome_frug_md$Frugivore_degree[which(biome_frug_md$Frug_Population_Trend == "Increasing")])

```
__Mean degree for frugivores in with decreasing population sizes:__

```{r biome mean degree of frugivores with shrinking pops}

mean(biome_frug_md$Frugivore_degree[which(biome_frug_md$Frug_Population_Trend == "Decreasing")])

```

__What do the two groups' histograms look like? ("pops" = populations)__

```{r histograms for decreasing and high risk frugivore degrees at biome-scale}

par(mfrow=c(1,2))

hist(biome_frug_md$Frugivore_degree[which(biome_frug_md$Frug_Population_Trend == "Increasing")], breaks =20, main = "Biome\n frugivore degrees: inc. pop.", xlab = NULL)

hist(biome_frug_md$Frugivore_degree[which(biome_frug_md$Frug_Population_Trend == "Decreasing")], breaks = 20, main = "Biome\n frugivore degrees: dec. pop.", xlab = NULL)

```

  Like the other histograms, skewed with most frugivores interacting with less than 10 plant species, and a few hyper-generalists.

#### Ecoregion-scale: network degree for frugivores of increasing versus decreasing populations sizes

__Mean degrees per population trajectory category per ecoregion:__
```{r ecoregion frugivore mean degrees for pops that are shrinking versus growing}

# summarize - see means per group

eco_means_pops <- eco_temp %>% 
  dplyr::filter(Frug_Population_Trend == "Increasing"|Frug_Population_Trend == "Decreasing") %>%  # only interested in increasing and decreasing pops
  group_by(ecoregion, Frug_Population_Trend) %>%
  summarise(mean(Frugivore_degree)) 

names(eco_means_pops)[3] <- "mean" # name the column, will be used later in plots

eco_means_pops # look at it

```
General pattern seems to be that average degree values are higher in decreasing populations compared with increasing populations. 


__Visually look at and compare histograms for frugivore degrees between the two groups for each ecoregion:__

```{r histograms of frugivore degrees}

# clean

par(mfrow=c(3,2))

# cerrado

hist(cerrado_frug_md$Frugivore_degree[which(cerrado_frug_md$Frug_Population_Trend == "Increasing")], 
     breaks = 100, 
     main = "Cerrado frug degrees\n inc. pop", xlab=NULL)

hist(cerrado_frug_md$Frugivore_degree[which(cerrado_frug_md$Frug_Population_Trend == "Decreasing")], 
     breaks = 10, 
     main = "Cerrado frug degrees\n dec. pop.", xlab=NULL)

# serra do mar

hist(serra.do.mar_frug_md$Frugivore_degree[which(serra.do.mar_frug_md$Frug_Population_Trend == "Increasing")], 
     breaks = 10, 
     main = "Serra.do.Mar, inc. pop.", xlab=NULL)

hist(serra.do.mar_frug_md$Frugivore_degree[which(serra.do.mar_frug_md$Frug_Population_Trend == "Decreasing")], 
     breaks = 10, 
     main = "Serra.do.Mar, dec. pop.", xlab=NULL)

# mata caducifolia

hist(mata.caducifolia_frug_md$Frugivore_degree[which(mata.caducifolia_frug_md$Frug_Population_Trend == "Increasing")], 
     breaks = 10, 
     main = "Mata.caducifolia, inc. pop.", xlab=NULL)

hist(mata.caducifolia_frug_md$Frugivore_degree[which(mata.caducifolia_frug_md$Frug_Population_Trend == "Decreasing")], 
     breaks = 10, 
     main = "Mata.caducifolia, dec. pop.", xlab= NULL)

```

Looks like cerrado doesn't have many frugivores with increasing populations, and those that it does have don't disperse many spp.

__Number of frugivore species in decreasing and increasing population groups: biome-scale__
```{r summarise how many species in each population growth trend category at biome level}

biome_frug_md %>% group_by(Frug_Population_Trend) %>%
  summarise(count = length(Frugivore_Species))

```

  Interesting to note that a pretty large portion are decreasing or have stable populations.

__Number of frugivore species in decreasing and increasing population groups: ecoregion-scale__

```{r summarise number frugivores per pop category at ecoregion level, message=FALSE}
eco_temp %>% 
  dplyr::filter(Frug_Population_Trend == "Increasing"|Frug_Population_Trend == "Decreasing") %>% 
  group_by(ecoregion, Frug_Population_Trend) %>%
  summarise(length(Frugivore_Species)) 
```

  As opposed to the 'high risk' and 'low risk' categories, here, those species that are increasing are few in number while many more are in the decreasing population category. 



### Analysis 2: Negative binomial model examining relationship between frugivore population growth trends and degree

```{r analysis 2 component 1}

biome_frug_popsubset <- biome_frug_md %>%
  dplyr::filter(Frug_Population_Trend
                == 'Increasing'|Frug_Population_Trend 
                == 'Decreasing') # Just interested in increasing and decreasing populations, subset a temporary dataframe with just those groups


biome.deg.m2 <- glm.nb(subzero ~ Frug_Population_Trend, data = biome_frug_popsubset) # Negative binomial model looking at frugivore degree and population trend status; continuing to use the transformed degree data as with Analysis 1 model

summary(biome.deg.m2) # look at output

aov.biome.deg.m2 = Anova(biome.deg.m2) # simplify model results

aov.biome.deg.m2 # display model results in simplified form



# clean

rm(aov.biome.deg.m2, out.aov.biome.deg.m2)

```

__Summary__
    + Frugivores belonging in the decreasing population category disperse a near- significantly greater variety of seeds than those with growing population sizes (Chisq = 3.12, p = 0.077)



### Analysis 2: model validation

```{r model validation analysis 2}

sim.out.biome.deg.m2 <- simulateResiduals(fittedModel = biome.deg.m2, plot = F)

plot(sim.out.biome.deg.m2) # plot residual plots

testDispersion(sim.out.biome.deg.m2, plot = F) # print dispersion results

testZeroInflation(sim.out.biome.deg.m2, plot = F) # print zero-inflation results

# clean

rm(sim.out.biome.deg.m2, biome.deg.m2)

```

  __Summary:__ 
When run with the frugivore degree values minus 1 (to allow for zeros in the data), our data meets the negative binomial model assumptions. 



### Analysis 2: biome-scale figure showing degree values of frugivores in increasing and decreasing populations

* Negative binomial model output is included in this plot of frugivore network degree at the biome-scale, split into frugivores with increasing and decreasing global populations.
    + the mean values are added as black triangles
    + 95% CIs are bars around means computed from 1000 bootstraps

```{r bootstrap CIs around mean degree of frugivores in each population category, cache=TRUE}

# frugivores with increasing population trends = INC, those with decreasing pops = DEC

biome_bootstrap.DEC <- bootstrapnb(biome_frug_md$Frugivore_degree
                                   [which(biome_frug_md$Frug_Population_Trend 
                                          == "Decreasing")], 
                                   m = 1000, 
                                   alpha = 0.95)

biome_bootstrap.INC <- bootstrapnb(biome_frug_md$Frugivore_degree
                                   [which(biome_frug_md$Frug_Population_Trend 
                                          == "Increasing")],
                                   m = 1000, 
                                   alpha = 0.95)


# 'temp2' is a temp storage data frame to stick CI vals into for graphing

biome_bootstrap.temp2 <- data.frame(matrix(vector(),1, 5,
                dimnames=list(c(), 
                              c("Region", "Frug_Population_Trend", 
                                "mean", "lower.95", "upper.95")))) # make the temp df

biome_bootstrap.temp2[1] <- "Atlantic_Forest"

biome_bootstrap.temp2[2] <-"Decreasing"

biome_bootstrap.temp2[3] <- mean(biome_frug_md$Frugivore_degree
                                 [which(biome_frug_md$Frug_Population_Trend ==
                                          "Decreasing")])

biome_bootstrap.temp2[4] <- biome_bootstrap.DEC[[1]] 

biome_bootstrap.temp2[5] <- biome_bootstrap.DEC[[5]]

biome_bootstrap.temp2[2,1] <- "Atlantic_Forest"

biome_bootstrap.temp2[2,2] <-"Increasing"

biome_bootstrap.temp2[2,3] <-mean(biome_frug_md$Frugivore_degree
                                  [which(biome_frug_md$Frug_Population_Trend ==
                                           "Increasing")])

biome_bootstrap.temp2[2,4] <- biome_bootstrap.INC[[1]] 

biome_bootstrap.temp2[2,5] <- biome_bootstrap.INC[[5]]

```
Above code computes bootstrapped 95% confidence intervals around mean degree of frugivores in increasing vs decreasing populations(1000 iterations).
```{r version 1 fig 2b degree vs pop trend, warning=FALSE, eval = FALSE}

biome_deg.pop.trend.plot <- biome_frug_popsubset %>%
  
ggplot(aes(x = Frug_Population_Trend, y = Frugivore_degree, 
           color = Frug_Population_Trend)) + 
  
  geom_point(size = 2, shape = 16, alpha = 0.7, # display data for each frug individually
             position=position_jitterdodge(jitter.width = 0.15)) + 
  
  geom_pointrange(data = biome_bootstrap.temp2, 
                  mapping = aes(x = Frug_Population_Trend, y = mean, 
                                ymax = upper.95, ymin = lower.95, 
                                color = "black"), size = 0.4, shape = 17) + # include mean and 95% CIs
  
  theme_bw() + labs(y="Trees dispersed", x = NULL) +
  
  theme(axis.text=element_text(colour="black", size = 8)) +
  
  theme(axis.title = element_text(size = 10)) + 
  
  scale_x_discrete(labels = c("Decreasing", "Increasing")) +
  
  scale_colour_manual(labels = c("Group mean", "Decreasing", "Increasing"), 
                      values = c("coral1", "deepskyblue3")) +
  
  theme(legend.title=element_blank()) + # no legend title
  
  theme(legend.position = "none") + # put legend on bottom
  
  annotate(geom="text", size = 3.25, x = 1.5, y = 128, 
           label = bquote(~italic(X^2)~'= 3.12,'~italic(p)~ '= 0.08')) + # add model results
  
  ggtitle("Biome\n\nFrugivore diet breadth:\ndecreasing versus increasing populations") +
  
  theme(plot.title = element_text(size = 10)) +
  
  theme(plot.title=element_text(hjust = 0.5)) +
  
  labs(tag = "(b)")

biome_deg.pop.trend.plot # display plot

legend.pop.trend <- get_legend(biome_deg.pop.trend.plot, position = "bottom") # get legend to add to panel figure later

legend.pop.trend <- as_ggplot(legend.pop.trend) # convert to ggplot

# clean

# rm(biome_bootstrap.DEC, biome_bootstrap.INC, biome_frug_popsubset, biome_bootstrap.temp2)

```

Code for first version of fig 2a using jittered points to show frugivore degree data in each increasing and decreasing population category across the Atlantic Forest biome.

```{r version 2 fig 2b revised biome scale degree vs population growth trends as violin plot, warning=FALSE}

biome_deg.pop.trend.vplot <- biome_frug_popsubset %>%
  ggplot(aes(x = Frug_Population_Trend, y = Frugivore_degree, 
           fill = Frug_Population_Trend, group = Frug_Population_Trend)) + 
  
  geom_violin(trim = FALSE, alpha = 0.80) + # use violin plot to show data distribution
  
  geom_pointrange(data = biome_bootstrap.temp2, 
                  mapping = aes(x = Frug_Population_Trend, y = mean, 
                                ymax = upper.95, ymin = lower.95), 
                                color = "black", size = 0.75, shape = 16) + # include mean and 95% CIs
  theme_bw() + labs(y="Trees dispersed", x = NULL) +
  
  theme(axis.text=element_text(colour="black", size = 8)) +
  
  theme(axis.title = element_text(size = 10)) + 
  
  scale_x_discrete(labels = c("Decreasing", "Increasing")) +
  
  scale_colour_manual(labels = c("Group mean", "Decreasing", "Increasing"), 
                      values = c("coral1", "deepskyblue4")) +
  
  theme(legend.title=element_blank()) + # no legend title
  
  theme(legend.position = "none") + # put legend on bottom
  
  annotate(geom="text", size = 3.25, x = 1.5, y = 128, 
           label = bquote(~italic(X^2)~'= 3.12,'~italic(p)~ '= 0.08')) + # add model results
  
  ggtitle("Biome\n\nFrugivore diet breadth:\ndecreasing versus increasing populations") +
  
  theme(plot.title = element_text(size = 10)) +
  
  theme(plot.title=element_text(hjust = 0.5)) +
  
  labs(tag = "(b)")

```

This violin plot shows frugivore degree frugivores belonging to populations that are shrinking globally and those that are currently growing. Bars show 95% CIs around the mean (which is shown as black triangle for each group), calculated from 1000 bootstrap iterations.

## Ecoregion scale ploting of frugivore degrees in high vs low extinction risk groups and also in decreasing vs increasing population groups

There is insufficient data in many of these categories at the ecoregion scale (see the data overview section of ecoregions above in Analysis 1 and Analysis 2 prep) to repeat the models that were done at the biome scale analyzing differences in degree between frugivores that belong to either higher or lower extinction risk categories (Analysis 1 above) or decreasing or increasing populations (Analysis 2 above). Although we can't run sufficiently robust analyses, we can at least gain an understanding of trends by looking at the data.

```{r ecoregion high versus low extinction risk plots}

cerrado_frug_md$ecoregion <- "cerrado" # add ecoregion column bc I'm going to make a temp df with all ecoregions rbinded for graphing

serra.do.mar_frug_md$ecoregion <- "serra.do.mar"

mata.caducifolia_frug_md$ecoregion <- "mata.caducifolia"

# subset the columns I will want for plotting:

# cerrado

eco_temp.cer <- cerrado_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, 
                Frug_Population_Trend, Frugivore_degree, ecoregion) 

# serra do mar

eco_temp.ser <- serra.do.mar_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, 
                 Frug_Population_Trend, Frugivore_degree, ecoregion)

# mata caducifolia

eco_temp.mata <- mata.caducifolia_frug_md %>%
  dplyr::select(Frugivore_Species, Frug_risk_level, 
                 Frug_Population_Trend, Frugivore_degree, ecoregion)

eco_temp <- rbind(eco_temp.cer, eco_temp.ser, eco_temp.mata) # combine them into a temp df for plotting

eco_means_risk <- eco_temp %>% # I'm going to plot the means as well, so make another temp df with means
  group_by(ecoregion, Frug_risk_level) %>%
  summarise(mean(Frugivore_degree)) 

names(eco_means_risk)[3] <- "mean" # name the column

# make the plot

ecoregion_deg.risk.plot <- eco_temp %>%
ggplot(aes(x = ecoregion, y = Frugivore_degree, fill = Frug_risk_level)) + 
  geom_violin(trim = FALSE, alpha = 0.80) +
  #geom_point(size = 2, shape = 16, alpha = 0.7, # display data for each frug individually
   #          position=position_jitterdodge(jitter.width = 0.15)) + 
  geom_point(data = eco_means_risk, # use the temp df of means per ecoregion per category here
                  mapping = aes(x = ecoregion, y = mean, 
                                fill = Frug_risk_level), 
             position = position_dodge(width = 0.9), color = "black", size = 2, shape = 16) + 
  
  theme_bw() + labs(y="Trees dispersed", x = NULL) +
  
  theme(axis.text=element_text(colour="black", size = 8)) +
  
  theme(axis.title = element_text(size = 10)) + 
  
  scale_x_discrete(labels = c("Cerrado", "Mata caducifolia", "Serra do Mar")) +
  
  scale_fill_manual(labels = c("Group mean", "Higher risk", "Lower risk"), 
                      values = c("firebrick4", "goldenrod3")) +
  
  theme(legend.title = element_blank()) +
  
  theme(legend.position = "none") + # no legend
  
  guides(color = guide_legend(override.aes = list(shape = c(17, 16, 16)))) +
  
  ggtitle("Ecoregions\n\nFrugivore diet breadth:\nhigh versus low endangerment status") +
  
  theme(plot.title = element_text(size = 10)) +
  
  theme(plot.title=element_text(hjust = 0.5)) +
  
  labs(tag = "(c)")

legend_risk <- get_legend(ecoregion_deg.risk.plot, position = "bottom") # extract legend to add to panel later

legend_risk <- as_ggplot(legend_risk) # convert legend to ggplot for easy use later

```

```{r ecoregion increasing versus decreasing population sizes plots}

ecoregion_pop_subset <- eco_temp %>%
  dplyr::filter(Frug_Population_Trend == "Increasing" | Frug_Population_Trend == "Decreasing")

# make the plot

ecoregion_deg.pop.plot <- ecoregion_pop_subset %>% 
  ggplot(aes(x = ecoregion, y = Frugivore_degree, fill = Frug_Population_Trend)) + 
  
  geom_violin(trim = FALSE, alpha = 0.80) +
  # geom_point(size = 2, shape = 16, alpha = 0.7, # display data for each frug individually
            # position=position_jitterdodge(jitter.width = 0.15)) + 
  geom_point(data = eco_means_pops, # use the temp df of means per ecoregion per category here
             mapping = aes(x = ecoregion, y = mean, group = Frug_Population_Trend), 
             color = "black", position = position_dodge(width = 0.9), size = 2, 
             shape = 16) +
  
  theme_bw() + labs(y="Trees dispersed", x = NULL) +
  
  theme(axis.text=element_text(colour="black", size = 8)) +
  
  theme(axis.title = element_text(size = 10)) + 
  scale_x_discrete(labels = c("Cerrado", "Mata Caducifolia", "Serra do Mar")) +
  
  scale_colour_manual(labels = c("Group mean", "Decreasing", "Increasing"), 
                      
                      values = c("coral1", "deepskyblue3")) +
  theme(legend.title = element_blank()) +
  
  theme(legend.position = "none") + # no legend
  
  guides(color = guide_legend(override.aes = list(shape = c(17, 16, 16)))) +
  ggtitle("Ecoregions\n\nFrugivore diet breadth:\ndecreasing versus increasing populations") + theme(plot.title = element_text(size = 10)) +
  theme(plot.title=element_text(hjust = 0.5)) + labs(tag = "(d)")

legend_pop.trend <- get_legend(ecoregion_deg.pop.plot, position = "bottom") # extract legend to add to panel later

legend_pop.trend <- as_ggplot(legend_pop.trend) # convert legend to ggplot for easy use later

ecoregion_deg.pop.plot

```

```{r combine all degree comparison figures, warning=FALSE}

save <- ggarrange(biome_deg.risk.level.vplot, biome_deg.pop.trend.vplot, ecoregion_deg.risk.plot, ecoregion_deg.pop.plot, ncol = 2, nrow = 2, heights = c(8,8,1))

save # look at it

# save it 
#ggsave(save, file = "plots/revised_degree_comparison_panel_vplots.pdf", units = "in", width = 6.75, height = 8, dpi = 400)

# save as png to put in manuscript
#ggsave(save, file = "plots/revised_degree_comparison_panel_vplots.png", units = "in", width = 6.75, height = 8, dpi = 400)
```

Panel figure for manuscript. Shows general trend of decreasing population sizes and endangerment status both being associated with higher frugivore degree compared to frugivore species that are doing better int he face of anthropogenic pressures. 



## Analysis 3: Simulations of frugivore species removals
  + This consists of for loops that create:
  + (1) A random removal scenario, then scenarios in which frugivores are removed in decreasing order of (2) endangerment status, (3) degree, and (4) body mass. 
  + Each scenario is run at the biome-scale and then replicated at the ecoregion scale
  + For random removal and within each endangerment status, 1000 iterations are run and then 1000 bootstraps are run to get 95% CIs (and the code for iteration steps takes a long time to run)

### Load function used in bootstrapping later

```{r mean function nothing fancy}
meanfun <- function(data, i){
  d <- data[i, ]
  return(mean(d))   
} #function to take mean - boot package is interesting and you have to write your own function for the 'statistic' argument as far as I can tell
```
 The boot package uses this for the 'statistic' argument for estimating our means for number of plants left per removal.

### Random removal

Examine co-extinctions of plant species and network robustness under 1000 simulations of randomly losing species

#### Biome-scale random removal simulations and bootstrapping CIs

Following two code chunks simulate random removals and bootstrap mean estimates and upper/lower 95% confidence interavals for the biome network.
```{r biome random removals, cache = TRUE}
# run this on 'biome.mat' - the interaction matrix for the full biome
# cache results bc this takes about 30 min to run

biome_robustness_vector_random <- rep(NA, 1000)

biome_plant_survivors_vector_random<- list()

for(j in 1:1000) {
  
  s1.biome.random <- sample(biome_frug_md[ ,'Frugivore_Species'])
  
  triggerlist.biome.random <- list()
  
  for(i in 1:length(s1.biome.random)) {
    triggerlist.biome.random[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s1.biome.random[i])], length(which(biome_frug_md$Frugivore_Species == s1.biome.random[i])))
  }
  
  triggerlist.biome.random <- unlist(triggerlist.biome.random)
  
  triggerlist.biome.random <- as.character(triggerlist.biome.random)
  
  new.mat.biome.random<-list() #making an empty new object
  
  new.mat.biome.random[[1]]<- biome.mat #specifying the first element will be the original, full matrix
  
  for(i in 1:length(triggerlist.biome.random)) {
    mat.biome.random <- new.mat.biome.random[[i]]
    mat.biome.random[ ,which(colnames(mat.biome.random) == triggerlist.biome.random[i])]<-0
    new.mat.biome.random[[i+1]] <- mat.biome.random
  }
  
  biome.survivors.ll <-NULL
  biome.survivors.ll[[1]] <- nrow(biome.mat)
  
  for(i in 1:length(new.mat.biome.random)) {biome.survivors.ll[i] <- length(which(rowSums(new.mat.biome.random[[i]])>0))}
  
  biome_plant_survivors_vector_random[[j]]<-biome.survivors.ll
  
  unlist(biome.survivors.ll)
  
  biome.robustness.ll <-(sum(unlist(biome.survivors.ll)))/((ncol(biome.mat))*(nrow(biome.mat)))
  
  biome_robustness_vector_random[j] <- biome.robustness.ll
}

# extract plant survivor counts and get them into a workable form

# copy the time survivors output in case I mess it up, since it is time consuming to make
biome_plant_survivors_vector_random_copy <- biome_plant_survivors_vector_random
# create an empty dataframe and put in my frugivore removal counts
biome_plant_survivors_random_df<-as.data.frame(seq(from = 0, to = 321))
# doesn't behave unless I unlist the survivors vector
# this loop does that and sticks the values into my dataframe with the frugivore removal counts
for(i in 1:length(biome_plant_survivors_vector_random_copy)) {temp_biome_random<-unlist(biome_plant_survivors_vector_random_copy[[i]])
biome_plant_survivors_random_df[,i]<-temp_biome_random}

# I have to transpose it though to get it into a format I can bootstrap etc with easily
# transposing function isn't working unless it is a matrix, so make it a matrix...
biome_plant_survivors_random_mat<-as.matrix(biome_plant_survivors_random_df)
# now transpose that matrix
biome_plant_survivors_random_mat<-t(biome_plant_survivors_random_mat)
# to run my loop below to get the confidence intervals though, I need it back in dataframe format:
biome_plant_survivors_random<-as.data.frame(biome_plant_survivors_random_mat)

# Summary of output pieces:

# 'biome_robustness_vector_random' is a vector of all the robustness values created during each removal over each iteration

# 'biome_plant_survivors_random' has the number of plants surviving at each removal step, for each iteration

# clean

rm(i, j, s1.biome.random, triggerlist.biome.random, new.mat.biome.random, biome.survivors.ll, biome_plant_survivors_vector_random, biome.robustness.ll, biome_plant_survivors_vector_random_copy, biome_plant_survivors_random_df, temp_biome_random, biome_plant_survivors_random_mat) 

```

```{r biome bootstraps ci random removal, cache=TRUE}

biome_random.means.boot<-list() #create empty list to store means

biome_random.upper.cis<-list() #create empty list to store upper CI's

biome_random.lower.cis<-list() #crate empty list to store lower CI's

# loop bootstraps mean and CI's of n lower level survivors for each n frugs removed
# takes ~2.5 hours

# this will not run with the starting value of plants (777) bc every iteration has that same value obviously, and you can't bootstrap data without variation. Same problem with the last values in the removal simulations (the zeros). 

biome_plant_survivors_random<-biome_plant_survivors_random[,-c(1, 322)]

for(i in 1:length(biome_plant_survivors_random)){
  
  means.biome.random <- boot(biome_plant_survivors_random[i], R = 1200, statistic = meanfun) #bootstrap estimate of means for each column
  
  biome.random.mean.int.95.BCa <- boot.ci(means.biome.random, conf = 0.95, type = "bca") #bootstrap's bias corrected confidence intervals
  
  biome_random.lower.cis[[i+1]]<-biome.random.mean.int.95.BCa$bca[1,4] #extract and save lower confidence interval
  biome_random.upper.cis[[i+1]]<-biome.random.mean.int.95.BCa$bca[1,5] #same with upper ci
  biome_random.means.boot[[i+1]] <- means.biome.random$t0 
}


# get it into a workable form
# add column labels, first (0) and last (777) values, combine dataframes

biome_random.means.boot<-as.data.frame(unlist(biome_random.means.boot))
names(biome_random.means.boot)[1]<-"mean"
biome_random.means.boot<-biome_random.means.boot %>% add_row(mean = 0) 
biome_random.means.boot<-biome_random.means.boot %>% add_row(mean = 777,.before = 1)

biome_random.lower.cis<-as.data.frame(unlist(biome_random.lower.cis))

names(biome_random.lower.cis)[1]<-"lower_95.ci"
biome_random.lower.cis<-biome_random.lower.cis %>% add_row(lower_95.ci = 0) 
biome_random.lower.cis<-biome_random.lower.cis %>% add_row(lower_95.ci = 777, .before = 1)

biome_random.upper.cis<-as.data.frame(unlist(biome_random.upper.cis))
names(biome_random.upper.cis)[1]<-"upper_95.ci"
biome_random.upper.cis<-biome_random.upper.cis %>% add_row(upper_95.ci = 0) 
biome_random.upper.cis<-biome_random.upper.cis %>% add_row(upper_95.ci = 777, .before = 1)

biome_plant_survivors_random_btstrped<-cbind(biome_random.means.boot, biome_random.upper.cis, biome_random.lower.cis)

biome_plant_survivors_random_btstrped$n_frugs_removed<-seq(from = 0, to = 321) #for graphing, add column with the number frugivores removed per step to df

# clean

rm(biome_random.means.boot, biome_random.upper.cis, biome_random.lower.cis, biome_plant_survivors_random, means.biome.random, i, biome.random.mean.int.95.BCa) 

```

#### Ecoregion-scale random removal simulations and bootstrapping CIs

The above is repeated for each ecoregion.

##### Cerrado
Following two code chunks simulate random removals and bootstrap mean estimates and upper/lower 95% confidence interavals for the cerrado network.
```{r cerrado random removals, cache = TRUE}
# run this on 'mat.cerrado' - the interaction matrix for the cerrado ecoregion
cerrado_robustness_vector_random <- rep(NA, 1000)
cerrado_plant_survivors_vector_random<- list()

for(j in 1:1000) {
  
  s1.cerrado.random <- sample(cerrado_frug_md[ ,'Frugivore_Species'])
  
  triggerlist.cerrado.random <- list()
  
  for(i in 1:length(s1.cerrado.random)) {
    triggerlist.cerrado.random[[i]] <- sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frugivore_Species == s1.cerrado.random[i])], length(which(cerrado_frug_md$Frugivore_Species == s1.cerrado.random[i])))
  }
  
  triggerlist.cerrado.random <- unlist(triggerlist.cerrado.random)
  
  triggerlist.cerrado.random <- as.character(triggerlist.cerrado.random)
  
  new.mat.cerrado.random<-list() #making an empty new object
  
  new.mat.cerrado.random[[1]]<-mat.cerrado #specifying the first element will be the original, full matrix
  
  for(i in 1:length(triggerlist.cerrado.random)) {
    mat.cerrado.random <- new.mat.cerrado.random[[i]]
    mat.cerrado.random[ ,which(colnames(mat.cerrado.random) == triggerlist.cerrado.random[i])]<-0
    new.mat.cerrado.random[[i+1]] <- mat.cerrado.random
  }
  
  survivors.cerrado.random.ll <-NULL
  survivors.cerrado.random.ll[[1]] <- nrow(mat.cerrado)
  
  for(i in 1:length(new.mat.cerrado.random)) {survivors.cerrado.random.ll[i] <- length(which(rowSums(new.mat.cerrado.random[[i]])>0))}
  
  cerrado_plant_survivors_vector_random[[j]]<-survivors.cerrado.random.ll
  
  unlist(survivors.cerrado.random.ll)
  
  robustness.cerrado.random.ll <-(sum(unlist(survivors.cerrado.random.ll)))/((ncol(mat.cerrado))*(nrow(mat.cerrado)))
  
  cerrado_robustness_vector_random[j] <- robustness.cerrado.random.ll
}

# extract plant survivor counts and get them into a workable form
# copy the time survivors output in case I mess it up, since it is time consuming to make
cerrado_plant_survivors_vector_random_copy <- cerrado_plant_survivors_vector_random
# create an empty dataframe and put in my frugivore removal counts
cerrado_plant_survivors_random_df<-as.data.frame(seq(from = 0, to = 91))
# doesn't behave unless I unlist the survivors vector
# this loop does that and sticks the values into my dataframe with the frugivore removal counts
for(i in 1:length(cerrado_plant_survivors_vector_random_copy)) {temp_cerrado_random<-unlist(cerrado_plant_survivors_vector_random_copy[[i]])
cerrado_plant_survivors_random_df[,i]<-temp_cerrado_random}

# I have to transpose it though to get it into a format I can bootstrap etc with easily
# transposing function isn't working unless it is a matrix, so make it a matrix...
cerrado_plant_survivors_random_mat<-as.matrix(cerrado_plant_survivors_random_df)
# now transpose that matrix
cerrado_plant_survivors_random_mat<-t(cerrado_plant_survivors_random_mat)
# to run my loop below to get the confidence intervals though, I need it back in dataframe format:
cerrado_plant_survivors_random<-as.data.frame(cerrado_plant_survivors_random_mat)

# Summary of output pieces:

# 'cerrado_robustness_vector_random' is a vector of all the robustness values created during each removal over each iteration

# 'cerrado_plant_survivors_random' is a big dataframe with the number of plants surviving at each removal step, for each iteration (N=1000)

# clean:
rm(i, j, s1.cerrado.random, triggerlist.cerrado.random, new.mat.cerrado.random, survivors.cerrado.random.ll, cerrado_plant_survivors_vector_random, robustness.cerrado.random.ll, cerrado_plant_survivors_vector_random_copy, cerrado_plant_survivors_random_df, temp_cerrado_random, cerrado_plant_survivors_random_mat)
```

```{r cerrado bootstrap cis random frug removal, cache=TRUE}

cerrado_random.means.boot<-list() #create empty list to store means
cerrado_random.upper.cis<-list() #create empty list to store upper CI's
cerrado_random.lower.cis<-list() #crate empty list to store lower CI's

# loop bootstraps mean and CI's of n lower level survivors for each n frugs removed
#remove first and last columns bc they have no variation and can't be bootstrapped:

cerrado_plant_survivors_random<-cerrado_plant_survivors_random[,-c(1,92)]

for(i in 1:length(cerrado_plant_survivors_random)){
  
  means.cerrado.random <- boot(cerrado_plant_survivors_random[i], R = 1200, statistic = meanfun) #bootstrap estimate of means for each column
  
  cerrado.random.mean.int.95.BCa <- boot.ci(means.cerrado.random, conf = 0.95, type = "bca") #bootstrap's bias corrected confidence intervals
  
  cerrado_random.lower.cis[[i+1]]<-cerrado.random.mean.int.95.BCa$bca[1,4] #extract and save lower confidence interval
  cerrado_random.upper.cis[[i+1]]<-cerrado.random.mean.int.95.BCa$bca[1,5] #same with upper ci
  cerrado_random.means.boot[[i+1]] <- means.cerrado.random$t0  
}

# get it into a workable form
# add column labels and first (0) and last values, combine dataframes
cerrado_random.means.boot<-as.data.frame(unlist(cerrado_random.means.boot))
names(cerrado_random.means.boot)[1]<-"mean"

cerrado_random.means.boot<-cerrado_random.means.boot %>% add_row(mean = 0) 
cerrado_random.means.boot<-cerrado_random.means.boot %>% add_row(mean = 55, .before = 1)

cerrado_random.lower.cis<-as.data.frame(unlist(cerrado_random.lower.cis))
names(cerrado_random.lower.cis)[1]<-"lower_95.ci"

cerrado_random.lower.cis<-cerrado_random.lower.cis %>% add_row(lower_95.ci = 0) 
cerrado_random.lower.cis<-cerrado_random.lower.cis %>% add_row(lower_95.ci = 55, .before = 1) 

cerrado_random.upper.cis<-as.data.frame(unlist(cerrado_random.upper.cis))
names(cerrado_random.upper.cis)[1]<-"upper_95.ci"

cerrado_random.upper.cis<-cerrado_random.upper.cis %>% add_row(upper_95.ci = 0)
cerrado_random.upper.cis<-cerrado_random.upper.cis %>% add_row(upper_95.ci = 55, .before = 1) 

cerrado_plant_survivors_random_btstrped<-cbind(cerrado_random.means.boot, cerrado_random.upper.cis, cerrado_random.lower.cis)
cerrado_plant_survivors_random_btstrped$n_frugs_removed<-seq(from = 0, to = 91)

# clean

rm(cerrado_random.means.boot, cerrado_random.lower.cis, cerrado_random.upper.cis, cerrado.random.mean.int.95.BCa, cerrado_plant_survivors_random, means.cerrado.random, i)

```

##### Serra do Mar
Following two code chunks simulate random removals and bootstrap mean estimates and upper/lower 95% confidence intervals for the Serra do Mar network.
```{r serra.do.mar random removals, cache = TRUE}
# run this on 'mat.serra.do.mar' - the interaction matrix for the serra.do.mar ecoregion

serra.do.mar_robustness_vector_random <- rep(NA, 1000)

serra.do.mar_plant_survivors_vector_random<- list()

for(j in 1:1000) {
  
  s1.serra.do.mar.random <- sample(serra.do.mar_frug_md[ ,'Frugivore_Species'])
  
  triggerlist.serra.do.mar.random <- list()
  
  for(i in 1:length(s1.serra.do.mar.random)) {
    triggerlist.serra.do.mar.random[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s1.serra.do.mar.random[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s1.serra.do.mar.random[i])))
  }
  
  triggerlist.serra.do.mar.random <- unlist(triggerlist.serra.do.mar.random)
  
  triggerlist.serra.do.mar.random <- as.character(triggerlist.serra.do.mar.random)
  
  new.mat.serra.do.mar.random<-list() #making an empty new object
  
  new.mat.serra.do.mar.random[[1]]<-mat.serra.do.mar #specifying the first element will be the original, full matrix
  
  for(i in 1:length(triggerlist.serra.do.mar.random)) {
    mat.serra.do.mar.random <- new.mat.serra.do.mar.random[[i]]
    mat.serra.do.mar.random[ ,which(colnames(mat.serra.do.mar.random) == triggerlist.serra.do.mar.random[i])]<-0
    new.mat.serra.do.mar.random[[i+1]] <- mat.serra.do.mar.random
  }
  
  survivors.serra.do.mar.random.ll <-NULL
  survivors.serra.do.mar.random.ll[[1]] <- nrow(mat.serra.do.mar)
  
  for(i in 1:length(new.mat.serra.do.mar.random)) {survivors.serra.do.mar.random.ll[i] <- length(which(rowSums(new.mat.serra.do.mar.random[[i]])>0))}
  
  serra.do.mar_plant_survivors_vector_random[[j]]<-survivors.serra.do.mar.random.ll
  
  unlist(survivors.serra.do.mar.random.ll)
  
  robustness.serra.do.mar.random.ll <-(sum(unlist(survivors.serra.do.mar.random.ll)))/((ncol(mat.serra.do.mar))*(nrow(mat.serra.do.mar)))
  
  serra.do.mar_robustness_vector_random[j] <- robustness.serra.do.mar.random.ll
}


# extract plant survivor counts and get them into a workable form
# copy the time survivors output in case I mess it up, since it is time consuming to make
serra.do.mar_plant_survivors_vector_random_copy <- serra.do.mar_plant_survivors_vector_random

# create an empty dataframe and put in my frugivore removal counts
serra.do.mar_plant_survivors_random_df<-as.data.frame(seq(from = 0, to = 173))

# doesn't behave unless I unlist the survivors vector
# this loop does that and sticks the values into my dataframe with the frugivore removal counts
for(i in 1:length(serra.do.mar_plant_survivors_vector_random_copy)) {temp_serra.do.mar_random<-unlist(serra.do.mar_plant_survivors_vector_random_copy[[i]])
serra.do.mar_plant_survivors_random_df[,i]<-temp_serra.do.mar_random}

# I have to transpose it though to get it into a format I can bootstrap etc with easily
# transposing function isn't working unless it is a matrix, so make it a matrix...
serra.do.mar_plant_survivors_random_mat<-as.matrix(serra.do.mar_plant_survivors_random_df)
# now transpose that matrix
serra.do.mar_plant_survivors_random_mat<-t(serra.do.mar_plant_survivors_random_mat)
# to run my loop below to get the confidence intervals though, I need it back in dataframe format:
serra.do.mar_plant_survivors_random<-as.data.frame(serra.do.mar_plant_survivors_random_mat)

# Summary of output pieces:

# 'serra.do.mar_robustness_vector_random' is a vector of all the robustness values created during each removal over each iteration

# 'serra.do.mar_plant_survivors_random' is a big dataframe with the number of plants surviving at each removal step (columns), for each iteration (rows, N=1000)

# clean

#rm(i, j, s1.serra.do.mar.random, triggerlist.serra.do.mar.random, new.mat.serra.do.mar.random, survivors.serra.do.mar.random.ll, serra.do.mar_plant_survivors_vector_random, robustness.serra.do.mar.random.ll, serra.do.mar_plant_survivors_vector_random_copy, serra.do.mar_plant_survivors_random_df, temp_serra.do.mar_random, serra.do.mar_plant_survivors_random_mat)
```

```{r serra.do.mar bootstraps cis random frug, cache=TRUE}

serra.do.mar_random.means.boot<-list() #create empty list to store means
serra.do.mar_random.upper.cis<-list() #create empty list to store upper CI's
serra.do.mar_random.lower.cis<-list() #crate empty list to store lower CI's

#remove first and last columns bc they have no variation and can't be bootstrapped:
serra.do.mar_plant_survivors_random<-serra.do.mar_plant_survivors_random[,-c(1,174)] # 172 columns; got rid of first and last (0 and 246 vals)

# loop bootstraps mean and CI's of n lower level survivors for each n frugs removed

for(i in 1:length(serra.do.mar_plant_survivors_random)){
  
  means.serra.do.mar.random <- boot(serra.do.mar_plant_survivors_random[i], R = 1200, statistic = meanfun) #bootstrap estimate of means for each column
  
  serra.do.mar.random.mean.int.95.BCa <- boot.ci(means.serra.do.mar.random, conf = 0.95, type = "bca") #bootstrap's bias corrected confidence intervals
  
  serra.do.mar_random.lower.cis[[i+1]]<-serra.do.mar.random.mean.int.95.BCa$bca[1,4] #extract and save lower confidence interval
  serra.do.mar_random.upper.cis[[i+1]]<-serra.do.mar.random.mean.int.95.BCa$bca[1,5] #same with upper ci
  serra.do.mar_random.means.boot[[i+1]] <- means.serra.do.mar.random$t0  
}

# get it into a workable form
# add column labels and first (0) and last values, combine dataframes
serra.do.mar_random.means.boot<-as.data.frame(unlist(serra.do.mar_random.means.boot))
names(serra.do.mar_random.means.boot)[1]<-"mean"

serra.do.mar_random.means.boot<-serra.do.mar_random.means.boot %>% add_row(mean = 0) 
serra.do.mar_random.means.boot<-serra.do.mar_random.means.boot %>% add_row(mean = 246, .before = 1)

serra.do.mar_random.lower.cis<-as.data.frame(unlist(serra.do.mar_random.lower.cis))
names(serra.do.mar_random.lower.cis)[1]<-"lower_95.ci"

serra.do.mar_random.lower.cis<-serra.do.mar_random.lower.cis %>% add_row(lower_95.ci = 0) 
serra.do.mar_random.lower.cis<-serra.do.mar_random.lower.cis %>% add_row(lower_95.ci = 246, .before = 1) 

serra.do.mar_random.upper.cis<-as.data.frame(unlist(serra.do.mar_random.upper.cis))
names(serra.do.mar_random.upper.cis)[1]<-"upper_95.ci"

serra.do.mar_random.upper.cis<-serra.do.mar_random.upper.cis %>% add_row(upper_95.ci = 0)
serra.do.mar_random.upper.cis<-serra.do.mar_random.upper.cis %>% add_row(upper_95.ci = 246, .before = 1) 

serra.do.mar_plant_survivors_random_btstrped <- cbind(serra.do.mar_random.means.boot, serra.do.mar_random.upper.cis, serra.do.mar_random.lower.cis)


serra.do.mar_plant_survivors_random_btstrped$n_frugs_removed<-seq(from = 0, to = 173)

# clean

#rm(serra.do.mar_random.means.boot, serra.do.mar_random.lower.cis, serra.do.mar_random.upper.cis, serra.do.mar_plant_survivors_random, serra.do.mar.random.mean.int.95.BCa, means.serra.do.mar.random, i)
```

##### Mata Caducifolia
Following two code chunks simulate random removals and bootstrap mean estimates and upper/lower 95% confidence interavals for the mata caducifolia network.
```{r mata.caducifolia random removals, cache = TRUE}
mata.caducifolia_robustness_vector_random <- rep(NA, 1000)
mata.caducifolia_plant_survivors_vector_random<- list()

for(j in 1:1000) {
  
  s1.mata.caducifolia.random <- sample(mata.caducifolia_frug_md[ ,'Frugivore_Species'])
  
  triggerlist.mata.caducifolia.random <- list()
  
  for(i in 1:length(s1.mata.caducifolia.random)) {
    triggerlist.mata.caducifolia.random[[i]] <- sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frugivore_Species == s1.mata.caducifolia.random[i])], length(which(mata.caducifolia_frug_md$Frugivore_Species == s1.mata.caducifolia.random[i])))
  }
  
  triggerlist.mata.caducifolia.random <- unlist(triggerlist.mata.caducifolia.random)
  
  triggerlist.mata.caducifolia.random <- as.character(triggerlist.mata.caducifolia.random)
  
  new.mat<-list() #making an empty new object
  
  new.mat[[1]]<-mat.mata.caducifolia #specifying the first element will be the original, full matrix
  
  for(i in 1:length(triggerlist.mata.caducifolia.random)) {
    mat <- new.mat[[i]]
    mat[ ,which(colnames(mat) == triggerlist.mata.caducifolia.random[i])]<-0
    new.mat[[i+1]] <- mat
  }
  
  survivors.mata.caducifolia.random.ll <-NULL
  survivors.mata.caducifolia.random.ll[[1]] <- nrow(mat.mata.caducifolia)
  
  for(i in 1:length(new.mat)) {survivors.mata.caducifolia.random.ll[i] <- length(which(rowSums(new.mat[[i]])>0))}
  
  mata.caducifolia_plant_survivors_vector_random[[j]]<-survivors.mata.caducifolia.random.ll
  
  unlist(survivors.mata.caducifolia.random.ll)
  
  robustness.mata.caducifolia.random.ll <-(sum(unlist(survivors.mata.caducifolia.random.ll)))/((ncol(mat.mata.caducifolia))*(nrow(mat.mata.caducifolia)))
  
  mata.caducifolia_robustness_vector_random[j] <- robustness.mata.caducifolia.random.ll
}

# extract plant survivor counts and get them into a workable form
# copy the time survivors output in case I mess it up, since it is time consuming to make
mata.caducifolia_plant_survivors_vector_random_copy <- mata.caducifolia_plant_survivors_vector_random
# create an empty dataframe and put in my frugivore removal counts
mata.caducifolia_plant_survivors_random_df<-as.data.frame(seq(from = 0, to = 84))
# doesn't behave unless I unlist the survivors vector
# this loop does that and sticks the values into my dataframe with the frugivore removal counts
for(i in 1:length(mata.caducifolia_plant_survivors_vector_random_copy)) {temp_mata.caducifolia_random<-unlist(mata.caducifolia_plant_survivors_vector_random_copy[[i]])
mata.caducifolia_plant_survivors_random_df[,i]<-temp_mata.caducifolia_random}

# I have to transpose it though to get it into a format I can bootstrap etc with easily
# transposing function isn't working unless it is a matrix, so make it a matrix...
mata.caducifolia_plant_survivors_random_mat<-as.matrix(mata.caducifolia_plant_survivors_random_df)
# now transpose that matrix
mata.caducifolia_plant_survivors_random_mat<-t(mata.caducifolia_plant_survivors_random_mat)
# to run my loop below to get the confidence intervals though, I need it back in dataframe format:
mata.caducifolia_plant_survivors_random<-as.data.frame(mata.caducifolia_plant_survivors_random_mat)

# Summary of output pieces:

# 'mata.caducifolia_robustness_vector_random' is a vector of all the robustness values created during each removal over each iteration

# 'mata.caducifolia_plant_survivors_random' is a big dataframe with the number of plants surviving at each removal step, for each iteration (N=1000)

# clean

rm(i, j, s1.mata.caducifolia.random, triggerlist.mata.caducifolia.random, survivors.mata.caducifolia.random.ll, mata.caducifolia_plant_survivors_vector_random, robustness.mata.caducifolia.random.ll, mata.caducifolia_plant_survivors_vector_random_copy, mata.caducifolia_plant_survivors_random_df, temp_mata.caducifolia_random, mata.caducifolia_plant_survivors_random_mat)
```

```{r mata.caducifolia bootstrap cis random removal, cache=TRUE}

mata.caducifolia_random.means.boot<-list() #create empty list to store means

mata.caducifolia_random.upper.cis<-list() #create empty list to store upper CI's

mata.caducifolia_random.lower.cis<-list() #crate empty list to store lower CI's


#remove first and last columns bc they have no variation and can't be bootstrapped:
mata.caducifolia_plant_survivors_random<-mata.caducifolia_plant_survivors_random[,-c(1,85)]

# loop bootstraps mean and CI's of n lower level survivors for each n frugs removed

for(i in 1:length(mata.caducifolia_plant_survivors_random)){
  
  mata.caducifolia.random.means <- boot(mata.caducifolia_plant_survivors_random[i], R = 1200, statistic = meanfun) #bootstrap estimate of means for each column
  
  mata.caducifolia.random.mean.int.95.BCa <- boot.ci(mata.caducifolia.random.means, conf = 0.95, type = "bca") #bootstrap's bias corrected confidence intervals
  
  mata.caducifolia_random.lower.cis[[i+1]]<-mata.caducifolia.random.mean.int.95.BCa$bca[1,4] #extract and save lower confidence interval
  mata.caducifolia_random.upper.cis[[i+1]]<-mata.caducifolia.random.mean.int.95.BCa$bca[1,5] #same with upper ci
  mata.caducifolia_random.means.boot[[i+1]] <- mata.caducifolia.random.means$t0  
}


# get it into a workable form
# add column labels and first (0) and last values, combine dataframes
mata.caducifolia_random.means.boot<-as.data.frame(unlist(mata.caducifolia_random.means.boot))
names(mata.caducifolia_random.means.boot)[1]<-"mean"

mata.caducifolia_random.means.boot<-mata.caducifolia_random.means.boot %>% add_row(mean = 0) 
mata.caducifolia_random.means.boot<-mata.caducifolia_random.means.boot %>% add_row(mean = 129, .before = 1)

mata.caducifolia_random.lower.cis<-as.data.frame(unlist(mata.caducifolia_random.lower.cis))
names(mata.caducifolia_random.lower.cis)[1]<-"lower_95.ci"

mata.caducifolia_random.lower.cis<-mata.caducifolia_random.lower.cis %>% add_row(lower_95.ci = 0) 
mata.caducifolia_random.lower.cis<-mata.caducifolia_random.lower.cis %>% add_row(lower_95.ci = 129, .before = 1) 

mata.caducifolia_random.upper.cis<-as.data.frame(unlist(mata.caducifolia_random.upper.cis))
names(mata.caducifolia_random.upper.cis)[1]<-"upper_95.ci"

mata.caducifolia_random.upper.cis<-mata.caducifolia_random.upper.cis %>% add_row(upper_95.ci = 0)
mata.caducifolia_random.upper.cis<-mata.caducifolia_random.upper.cis %>% add_row(upper_95.ci = 129, .before = 1) 

mata.caducifolia_plant_survivors_random_btstrped<-cbind(mata.caducifolia_random.means.boot, mata.caducifolia_random.upper.cis, mata.caducifolia_random.lower.cis)
mata.caducifolia_plant_survivors_random_btstrped$n_frugs_removed<-seq(from = 0, to = 84)

# clean

rm(mata.caducifolia_random.means.boot, mata.caducifolia_random.lower.cis, mata.caducifolia_random.upper.cis, mata.caducifolia_plant_survivors_random, mata.caducifolia.random.mean.int.95.BCa, mata.caducifolia.random.means, i)

```



### Removal based on most to least endangered

Examine co-extinctions of plant species and network robustness under a frugivore loss scenario during which frugivore species are knocked out in order of most (Critically endangered category) to least (least concern) IUCN categories.
    + multiple species exist within each of the 5 IUCN categories (CR, EN, VU, NT, LC) so this is run 1000 times to get random lots of iterations of randomly removing frugivores within each category in descending order of endangerment status
    
#### Biome-scale endangerment-status-based removal simulations and bootstrapping CIs

Following two code chunks remove species in random order within each IUCN category, moving through the categories sequentially from most to least concern. Means are bootstrapped and so are upper/lower 95% confidence intervals. This is first done at the biome scale.  

```{r biome iucn based removals, cache = TRUE}

rob.vec.IUCN <- rep(NA, 1000)

vec.survivors.IUCN.ll<- list()

for(j in 1:1000) {s1 <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frug_IUCN == "CR")])
triggerlist1 <- list()
  for(i in 1:length(s1)) {
    triggerlist1[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s1[i])], length(which(biome_frug_md$Frugivore_Species == s1[i])))
  }
  triggerlist1 <- unlist(triggerlist1)
  
  triggerlist1 <- as.character(triggerlist1)
  
  #-----------------------------------------#
s2 <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frug_IUCN == "EN")])
triggerlist2 <- list()
  for(i in 1:length(s2)) {
    triggerlist2[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s2[i])], length(which(biome_frug_md$Frugivore_Species == s2[i])))
  }
  triggerlist2 <- unlist(triggerlist2)
  
  triggerlist2 <- as.character(triggerlist2)
    #-----------------------------------------#
  s3 <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frug_IUCN == "VU")])
triggerlist3 <- list()
  for(i in 1:length(s3)) {
    triggerlist3[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s3[i])], length(which(biome_frug_md$Frugivore_Species == s3[i])))
  }
  triggerlist3 <- unlist(triggerlist3)
  
  triggerlist3 <- as.character(triggerlist3)
    #-----------------------------------------#
  s4 <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frug_IUCN == "NT")])
triggerlist4 <- list()
  for(i in 1:length(s4)) {
    triggerlist4[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s4[i])], length(which(biome_frug_md$Frugivore_Species == s4[i])))
  }
  triggerlist4 <- unlist(triggerlist4)
  
  triggerlist4 <- as.character(triggerlist4)
    #-----------------------------------------#
  #s5 should be those that are least concern AND declining in population
  s5 <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frug_IUCN == "LC" & biome_frug_md$Frug_Population_Trend == "Decreasing")])
triggerlist5 <- list()
  for(i in 1:length(s5)) {
    triggerlist5[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s5[i])], length(which(biome_frug_md$Frugivore_Species == s5[i])))
  }
  triggerlist5 <- unlist(triggerlist5)
  
  triggerlist5 <- as.character(triggerlist5)
  #-----------------------------------------#
  #s6 should be those that are LC and have a stable population trend
  s6 <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frug_IUCN == "LC" & biome_frug_md$Frug_Population_Trend == "Stable")])
triggerlist6 <- list()
  for(i in 1:length(s6)) {
    triggerlist6[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s6[i])], length(which(biome_frug_md$Frugivore_Species == s6[i])))
  }
  triggerlist6 <- unlist(triggerlist6)
  
  triggerlist6 <- as.character(triggerlist6)
  #------------------------------------------#
  #s7 should be those that are LC and have an increasing population trend
   s7 <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frug_IUCN == "LC" & biome_frug_md$Frug_Population_Trend == "Increasing")])
triggerlist7 <- list()
  for(i in 1:length(s7)) {
    triggerlist7[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s7[i])], length(which(biome_frug_md$Frugivore_Species == s7[i])))
  }
  triggerlist7 <- unlist(triggerlist7)
  
  triggerlist7 <- as.character(triggerlist7)
  #------------------------------------------#
  #s8 should be those that are LC and have an unknown population trend
   s8 <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frug_IUCN == "LC" & biome_frug_md$Frug_Population_Trend == "Unknown")])
triggerlist8 <- list()
  for(i in 1:length(s8)) {
    triggerlist8[[i]] <- sample(biome_frug_md$Frugivore_Species[which(biome_frug_md$Frugivore_Species == s8[i])], length(which(biome_frug_md$Frugivore_Species == s8[i])))
  }
  triggerlist8 <- unlist(triggerlist8)
  
  triggerlist8 <- as.character(triggerlist8)
  #------------------------------------------#
  #add trigger lists together to make 1 trigger list
  triggerlist <- c(triggerlist1, triggerlist2, triggerlist3, triggerlist4, triggerlist5, triggerlist6, triggerlist7, triggerlist8)
  #-----------------------------------------#
  new.mat<-list() #making an empty new object
  
  new.mat[[1]]<-biome.mat #specifying the first element will be the original, full matrix
  
  for(i in 1:length(triggerlist)) {
    mat <- new.mat[[i]]
    mat[ ,which(colnames(mat) == triggerlist[i])]<-0
    new.mat[[i+1]] <- mat
  }
  
  survivors.ll <-NULL
  survivors.ll[[1]] <- nrow(biome.mat)
  
  for(i in 1:length(new.mat)) {survivors.ll[i] <- length(which(rowSums(new.mat[[i]])>0))}
  
  vec.survivors.IUCN.ll[[j]]<-survivors.ll
  
  unlist(survivors.ll)
  
  Robustness.ll <-(sum(unlist(survivors.ll)))/((ncol(biome.mat))*(nrow(biome.mat)))
  
  rob.vec.IUCN[j] <- Robustness.ll
}

#extract survivor values into a workable form

vec.survivors.IUCN.ll_copy <- vec.survivors.IUCN.ll
biome_plant_survivors_IUCN_df<-as.data.frame(seq(from = 0, to = 321))

for(i in 1:length(vec.survivors.IUCN.ll_copy)) {temp_biome_IUCN<-unlist(vec.survivors.IUCN.ll_copy[[i]])
biome_plant_survivors_IUCN_df[,i]<-temp_biome_IUCN}

biome_plant_survivors_IUCN_mat<-as.matrix(biome_plant_survivors_IUCN_df)
biome_plant_survivors_IUCN_mat<-t(biome_plant_survivors_IUCN_mat)
biome_plant_survivors_IUCN<-as.data.frame(biome_plant_survivors_IUCN_mat)

# clean

rm(biome_plant_survivors_IUCN_mat, biome_plant_survivors_IUCN_df, Robustness.ll, survivors.ll, vec.survivors.IUCN.ll, vec.survivors.IUCN.ll_copy, i, j, new.mat, mat, triggerlist, triggerlist1, triggerlist2, triggerlist3, triggerlist4, triggerlist5, triggerlist6, triggerlist7, triggerlist8, rob.vec.IUCN, s1, s2, s3, s4, s5, s6, s7, s8, temp_biome_IUCN)
```

```{r biome iucn based removals bootstrapping, cache = TRUE}
biome_IUCN_means_boot<-list() #create empty list to store means

biome_IUCN_upper_cis<-list() #create empty list to store upper CI's

biome_IUCN_lower_cis<-list() #crate empty list to store lower CI's

biome_plant_survivors_IUCN <- biome_plant_survivors_IUCN[,-c(1, 6, 16, 26, 45, 116, 264, 293, 322)]


for(i in 1:length(biome_plant_survivors_IUCN)){
  
  means <- boot(biome_plant_survivors_IUCN[i], R = 1200, statistic = meanfun)
  
  mean.int.95.BCa <- boot.ci(means, conf = 0.95, type = "bca") 
  
  biome_IUCN_lower_cis[[i+1]]<-mean.int.95.BCa$bca[1,4] 
  biome_IUCN_upper_cis[[i+1]]<-mean.int.95.BCa$bca[1,5] 
  biome_IUCN_means_boot[[i+1]] <- means$t0  
}

biome_IUCN_means_boot<-as.data.frame(unlist(biome_IUCN_means_boot))
names(biome_IUCN_means_boot)[1]<-"mean"

biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 777, .before = 1)
biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 730, .before = 6) 
biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 628, .before = 16) 
biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 598, .before = 26) 
biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 574, .before = 45) 
biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 499, .before = 116)
biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 191, .before = 264)
biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 100, .before = 293)
biome_IUCN_means_boot<-biome_IUCN_means_boot %>% add_row(mean = 0) 

biome_IUCN_lower_cis<-as.data.frame(unlist(biome_IUCN_lower_cis))
names(biome_IUCN_lower_cis)[1]<-"lower_95.ci"

biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 777, .before = 1) 
biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 730, .before = 6) 
biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 628, .before = 16) 
biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 598, .before = 26) 
biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 574, .before = 45) 
biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 499, .before = 116)
biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 191, .before = 264)
biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 100, .before = 293)
biome_IUCN_lower_cis<-biome_IUCN_lower_cis %>% add_row(lower_95.ci = 0) 

biome_IUCN_upper_cis<-as.data.frame(unlist(biome_IUCN_upper_cis))
names(biome_IUCN_upper_cis)[1]<-"upper_95.ci"

biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 777, .before = 1) 
biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 730, .before = 6) 
biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 628, .before = 16) 
biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 598, .before = 26) 
biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 574, .before = 45) 
biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 499, .before = 116)
biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 191, .before = 264)
biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 100, .before = 293)
biome_IUCN_upper_cis<-biome_IUCN_upper_cis %>% add_row(upper_95.ci = 0) 

biome_plant_survivors_IUCN_btstrped<-cbind(biome_IUCN_means_boot, biome_IUCN_upper_cis, biome_IUCN_lower_cis)

biome_plant_survivors_IUCN_btstrped$n_frugs_removed<-seq(from = 0, to = 321)

# clean

rm(means, mean.int.95.BCa, i, biome_IUCN_lower_cis, biome_IUCN_upper_cis, biome_IUCN_means_boot, biome_plant_survivors_IUCN)
```


#### Ecoregion-scale endangerment-status-based removal simulations and boostrapping CIs
Following code remove species in random order within each IUCN category, moving through the categories sequentially from most to least concern. This is done per ecoregion in the following sections, along with bootstrapping mean estimates and upper/lower 95% confidence intervals. 
##### Cerrado
Cerrado ecoregion sequential elimination of endangered frugivores per IUCN category, followed by bootstrapping. 
```{r cerrado iucn based removals, cache=TRUE}
cerrado_robustness_vec_IUCN <- rep(NA, 1000)

cerrado_plant_survivors_vec_IUCN<- list()

for(j in 1:1000) {
cerrado_IUCN_s1 <- c(sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frug_IUCN == "CR")]), sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frug_IUCN == "EN")]), sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frug_IUCN == "VU")]), sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frug_IUCN == "LC" & cerrado_frug_md$Frug_Population_Trend == "Decreasing")]), sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frug_IUCN == "LC" & cerrado_frug_md$Frug_Population_Trend == "Unknown")]), sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frug_IUCN == "LC" & cerrado_frug_md$Frug_Population_Trend == "Stable")]), sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frug_IUCN == "LC" & cerrado_frug_md$Frug_Population_Trend == "Increasing")]))

cerrado_triggerlist.IUCN <- list()
  for(i in 1:length(cerrado_IUCN_s1)) {
    cerrado_triggerlist.IUCN[[i]] <- sample(cerrado_frug_md$Frugivore_Species[which(cerrado_frug_md$Frugivore_Species == cerrado_IUCN_s1[i])], length(which(cerrado_frug_md$Frugivore_Species == cerrado_IUCN_s1[i])))
  }
  cerrado_triggerlist.IUCN <- unlist(cerrado_triggerlist.IUCN)
  
  cerrado_triggerlist.IUCN <- as.character(cerrado_triggerlist.IUCN)
  #-----------------------------------------#
  cerrado_new.mat<-list() #making an empty cerrado_new object
  
  cerrado_new.mat[[1]]<-mat.cerrado #specifying the first element will be the original, full matrix
  
  for(i in 1:length(cerrado_triggerlist.IUCN)) {
    cerrado_mat <- cerrado_new.mat[[i]]
    cerrado_mat[ ,which(colnames(cerrado_mat) == cerrado_triggerlist.IUCN[i])]<-0
    cerrado_new.mat[[i+1]] <- cerrado_mat
  }
  
  cerrado_survivors.ll <-NULL
  cerrado_survivors.ll[[1]] <- nrow(mat.cerrado)
  
  for(i in 1:length(cerrado_new.mat)) {cerrado_survivors.ll[i] <- length(which(rowSums(cerrado_new.mat[[i]])>0))}
  
  cerrado_plant_survivors_vec_IUCN[[j]]<-cerrado_survivors.ll
  
  unlist(cerrado_survivors.ll)
  
  cerrado_robustness.ll <-(sum(unlist(cerrado_survivors.ll)))/((ncol(mat.cerrado))*(nrow(mat.cerrado)))
  
  cerrado_robustness_vec_IUCN[j] <- cerrado_robustness.ll
}

#extract survivor values into a workable form

cerrado_plant_survivors_vec_IUCN_copy <- cerrado_plant_survivors_vec_IUCN
cerrado_plant_survivors_IUCN_df<-as.data.frame(seq(from = 0, to = 91))
for(i in 1:length(cerrado_plant_survivors_vec_IUCN_copy)) {temp_cerrado_IUCN<-unlist(cerrado_plant_survivors_vec_IUCN_copy[[i]])
cerrado_plant_survivors_IUCN_df[,i]<-temp_cerrado_IUCN}

cerrado_plant_survivors_IUCN_mat<-as.matrix(cerrado_plant_survivors_IUCN_df)
cerrado_plant_survivors_IUCN_mat<-t(cerrado_plant_survivors_IUCN_mat)
cerrado_plant_survivors_IUCN<-as.data.frame(cerrado_plant_survivors_IUCN_mat)

# clean

rm(cerrado_plant_survivors_vec_IUCN_copy, cerrado_plant_survivors_IUCN_df, cerrado_plant_survivors_IUCN_mat, cerrado_robustness.ll,cerrado_survivors.ll, cerrado_new.mat, temp_cerrado_IUCN, cerrado_triggerlist.IUCN, cerrado_IUCN_s1, cerrado_plant_survivors_vec_IUCN, i, j)
```

```{r cerrado iucn based removals bootstrapping, cache=TRUE}

cerrado_IUCN_means_boot<-list() #create empty list to store means

cerrado_IUCN_upper_cis<-list() #create empty list to store upper CI's

cerrado_IUCN_lower_cis<-list() #crate empty list to store lower CI's

# per categorical removal step, there is no variation in final coextinction value bc no matter what ORDER frugivores are removed, in the end, the same frugivores are all absent from the network after a given category is completely extinct (even tho the order in which those frugs go extinct WITHIN that category is randomized per iteration of the simulation). We cannot bootstrap when there is no variation in network coextinction value, so I am pulling out those end point values below and manually adding them back to the resulting bootstrapped dataframe:

cerrado_plant_survivors_IUCN <- cerrado_plant_survivors_IUCN[,-c(1, 2, 3, 4, 24, 27, 85, 92)]

for(i in 1:length(cerrado_plant_survivors_IUCN)){
  
  means <- boot(cerrado_plant_survivors_IUCN[i], R = 1200, statistic = meanfun) #bootstrap estimate of means for each column
  
  mean.int.95.BCa <- boot.ci(means, conf = 0.95, type = "bca") #bootstrap's bias corrected confidence intervals
  
  cerrado_IUCN_lower_cis[[i+1]]<-mean.int.95.BCa$bca[1,4] #extract and save lower confidence interval
  cerrado_IUCN_upper_cis[[i+1]]<-mean.int.95.BCa$bca[1,5] #same with upper ci
  cerrado_IUCN_means_boot[[i+1]] <- means$t0  
}

# add the non-variation values back in and combine cerrado iucn based removals bootstrapped values
 
cerrado_IUCN_means_boot<-as.data.frame(unlist(cerrado_IUCN_means_boot))
names(cerrado_IUCN_means_boot)[1]<-"mean"

cerrado_IUCN_means_boot<-cerrado_IUCN_means_boot %>% add_row(mean = 55, .before = 1)
cerrado_IUCN_means_boot<-cerrado_IUCN_means_boot %>% add_row(mean = 52, .before = 2) 
cerrado_IUCN_means_boot<-cerrado_IUCN_means_boot %>% add_row(mean = 38, .before = 3) 
cerrado_IUCN_means_boot<-cerrado_IUCN_means_boot %>% add_row(mean = 38, .before = 4) 
cerrado_IUCN_means_boot<-cerrado_IUCN_means_boot %>% add_row(mean = 32, .before = 24) 
cerrado_IUCN_means_boot<-cerrado_IUCN_means_boot %>% add_row(mean = 31, .before = 27)
cerrado_IUCN_means_boot<-cerrado_IUCN_means_boot %>% add_row(mean = 6, .before = 85)
cerrado_IUCN_means_boot<-cerrado_IUCN_means_boot %>% add_row(mean = 0) 

cerrado_IUCN_lower_cis<-as.data.frame(unlist(cerrado_IUCN_lower_cis))
names(cerrado_IUCN_lower_cis)[1]<-"lower_95.ci"

cerrado_IUCN_lower_cis<-cerrado_IUCN_lower_cis %>% add_row(lower_95.ci = 55, .before = 1) 
cerrado_IUCN_lower_cis<-cerrado_IUCN_lower_cis %>% add_row(lower_95.ci = 52, .before = 2) 
cerrado_IUCN_lower_cis<-cerrado_IUCN_lower_cis %>% add_row(lower_95.ci = 38, .before = 3) 
cerrado_IUCN_lower_cis<-cerrado_IUCN_lower_cis %>% add_row(lower_95.ci = 38, .before = 4) 
cerrado_IUCN_lower_cis<-cerrado_IUCN_lower_cis %>% add_row(lower_95.ci = 32, .before = 24) 
cerrado_IUCN_lower_cis<-cerrado_IUCN_lower_cis %>% add_row(lower_95.ci = 31, .before = 27)
cerrado_IUCN_lower_cis<-cerrado_IUCN_lower_cis %>% add_row(lower_95.ci = 6, .before = 85)
cerrado_IUCN_lower_cis<-cerrado_IUCN_lower_cis %>% add_row(lower_95.ci = 0) 

cerrado_IUCN_upper_cis<-as.data.frame(unlist(cerrado_IUCN_upper_cis))
names(cerrado_IUCN_upper_cis)[1]<-"upper_95.ci"

cerrado_IUCN_upper_cis<-cerrado_IUCN_upper_cis %>% add_row(upper_95.ci = 55, .before = 1) 
cerrado_IUCN_upper_cis<-cerrado_IUCN_upper_cis %>% add_row(upper_95.ci = 52, .before = 2) 
cerrado_IUCN_upper_cis<-cerrado_IUCN_upper_cis %>% add_row(upper_95.ci = 38, .before = 3) 
cerrado_IUCN_upper_cis<-cerrado_IUCN_upper_cis %>% add_row(upper_95.ci = 38, .before = 4) 
cerrado_IUCN_upper_cis<-cerrado_IUCN_upper_cis %>% add_row(upper_95.ci = 32, .before = 24) 
cerrado_IUCN_upper_cis<-cerrado_IUCN_upper_cis %>% add_row(upper_95.ci = 31, .before = 27)
cerrado_IUCN_upper_cis<-cerrado_IUCN_upper_cis %>% add_row(upper_95.ci = 6, .before = 85)
cerrado_IUCN_upper_cis<-cerrado_IUCN_upper_cis %>% add_row(upper_95.ci = 0) 

cerrado_plant_survivors_IUCN_btstrped<-cbind(cerrado_IUCN_means_boot, cerrado_IUCN_upper_cis, cerrado_IUCN_lower_cis)

cerrado_plant_survivors_IUCN_btstrped$n_frugs_removed<-seq(from = 0, to = 91)

# clean

rm(means, mean.int.95.BCa, i, cerrado_IUCN_lower_cis, cerrado_IUCN_upper_cis, cerrado_IUCN_means_boot, cerrado_plant_survivors_IUCN)
```


##### Serra do Mar
Serra do Mar ecoregion sequential elimination of endangered frugivores per IUCN category, followed by bootstrapping. 
```{r serra.do.mar iucn based removals, cache=TRUE}
#I'm not sure why, but the triggerlists weren't randomizing and so I'm temporarily going back to my older code version of making EIGHT individual triggerlists then combining them after wards - very jenky but appears to fix issue

rob.vec.IUCN <- rep(NA, 1000)

vec.survivors.IUCN.ll<- list()

for(j in 1:1000) {s1 <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frug_IUCN == "CR")])
triggerlist1 <- list()
  for(i in 1:length(s1)) {
    triggerlist1[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s1[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s1[i])))
  }
  triggerlist1 <- unlist(triggerlist1)
  
  triggerlist1 <- as.character(triggerlist1)
  
  #-----------------------------------------#
s2 <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frug_IUCN == "EN")])
triggerlist2 <- list()
  for(i in 1:length(s2)) {
    triggerlist2[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s2[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s2[i])))
  }
  triggerlist2 <- unlist(triggerlist2)
  
  triggerlist2 <- as.character(triggerlist2)
    #-----------------------------------------#
  s3 <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frug_IUCN == "VU")])
triggerlist3 <- list()
  for(i in 1:length(s3)) {
    triggerlist3[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s3[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s3[i])))
  }
  triggerlist3 <- unlist(triggerlist3)
  
  triggerlist3 <- as.character(triggerlist3)
    #-----------------------------------------#
  s4 <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frug_IUCN == "NT")])
triggerlist4 <- list()
  for(i in 1:length(s4)) {
    triggerlist4[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s4[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s4[i])))
  }
  triggerlist4 <- unlist(triggerlist4)
  
  triggerlist4 <- as.character(triggerlist4)
    #-----------------------------------------#
  #s5 should be those that are least concern AND declining in population
  s5 <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frug_IUCN == "LC" & serra.do.mar_frug_md$Frug_Population_Trend == "Decreasing")])
triggerlist5 <- list()
  for(i in 1:length(s5)) {
    triggerlist5[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s5[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s5[i])))
  }
  triggerlist5 <- unlist(triggerlist5)
  
  triggerlist5 <- as.character(triggerlist5)
  #-----------------------------------------#
  #s6 should be those that are LC and have a stable population trend
  s6 <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frug_IUCN == "LC" & serra.do.mar_frug_md$Frug_Population_Trend == "Stable")])
triggerlist6 <- list()
  for(i in 1:length(s6)) {
    triggerlist6[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s6[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s6[i])))
  }
  triggerlist6 <- unlist(triggerlist6)
  
  triggerlist6 <- as.character(triggerlist6)
  #------------------------------------------#
  #s7 should be those that are LC and have an increasing population trend
   s7 <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frug_IUCN == "LC" & serra.do.mar_frug_md$Frug_Population_Trend == "Increasing")])
triggerlist7 <- list()
  for(i in 1:length(s7)) {
    triggerlist7[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s7[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s7[i])))
  }
  triggerlist7 <- unlist(triggerlist7)
  
  triggerlist7 <- as.character(triggerlist7)
  #------------------------------------------#
  #s8 should be those that are LC and have an unknown population trend
   s8 <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frug_IUCN == "LC" & serra.do.mar_frug_md$Frug_Population_Trend == "Unknown")])
triggerlist8 <- list()
  for(i in 1:length(s8)) {
    triggerlist8[[i]] <- sample(serra.do.mar_frug_md$Frugivore_Species[which(serra.do.mar_frug_md$Frugivore_Species == s8[i])], length(which(serra.do.mar_frug_md$Frugivore_Species == s8[i])))
  }
  triggerlist8 <- unlist(triggerlist8)
  
  triggerlist8 <- as.character(triggerlist8)
  #------------------------------------------#
  #add trigger lists together to make 1 trigger list
  triggerlist <- c(triggerlist1, triggerlist2, triggerlist3, triggerlist4, triggerlist5, triggerlist6, triggerlist7, triggerlist8)
  #-----------------------------------------#
  new.mat<-list() #making an empty new object
  
  new.mat[[1]]<-mat.serra.do.mar #specifying the first element will be the original, full matrix
  
  for(i in 1:length(triggerlist)) {
    mat <- new.mat[[i]]
    mat[ ,which(colnames(mat) == triggerlist[i])]<-0
    new.mat[[i+1]] <- mat
  }
  
  survivors.ll <-NULL
  survivors.ll[[1]] <- nrow(mat.serra.do.mar)
  
  for(i in 1:length(new.mat)) {survivors.ll[i] <- length(which(rowSums(new.mat[[i]])>0))}
  
  vec.survivors.IUCN.ll[[j]]<-survivors.ll
  
  unlist(survivors.ll)
  
  Robustness.ll <-(sum(unlist(survivors.ll)))/((ncol(mat.serra.do.mar))*(nrow(mat.serra.do.mar)))
  
  rob.vec.IUCN[j] <- Robustness.ll
}

#extract survivor values into a workable form

vec.survivors.IUCN.ll_copy <- vec.survivors.IUCN.ll
serra.do.mar_plant_survivors_IUCN_df<-as.data.frame(seq(from = 0, to = 173))

for(i in 1:length(vec.survivors.IUCN.ll_copy)) {temp_serra.do.mar_IUCN<-unlist(vec.survivors.IUCN.ll_copy[[i]])
serra.do.mar_plant_survivors_IUCN_df[,i]<-temp_serra.do.mar_IUCN}

serra.do.mar_plant_survivors_IUCN_mat<-as.matrix(serra.do.mar_plant_survivors_IUCN_df)
serra.do.mar_plant_survivors_IUCN_mat<-t(serra.do.mar_plant_survivors_IUCN_mat)
serra.do.mar_plant_survivors_IUCN<-as.data.frame(serra.do.mar_plant_survivors_IUCN_mat)

# clean

rm(serra.do.mar_plant_survivors_IUCN_mat, serra.do.mar_plant_survivors_IUCN_df, Robustness.ll, survivors.ll, vec.survivors.IUCN.ll, vec.survivors.IUCN.ll_copy, i, j, new.mat, mat, triggerlist, triggerlist1, triggerlist2, triggerlist3, triggerlist4, triggerlist5, triggerlist6, triggerlist7, triggerlist8, rob.vec.IUCN, s1, s2, s3, s4, s5, s6, s7, s8)

```

```{r serra.do.mar iucn based removals bootstrapping, cache =TRUE}
serra.do.mar_IUCN_means_boot<-list() #create empty list to store means

serra.do.mar_IUCN_upper_cis<-list() #create empty list to store upper CI's

serra.do.mar_IUCN_lower_cis<-list() #crate empty list to store lower CI's

serra.do.mar_plant_survivors_IUCN <- serra.do.mar_plant_survivors_IUCN[,-c(1, 2, 4, 8, 14, 50, 145, 159, 174)]


for(i in 1:length(serra.do.mar_plant_survivors_IUCN)){
  
  means <- boot(serra.do.mar_plant_survivors_IUCN[i], R = 1200, statistic = meanfun)
  
  mean.int.95.BCa <- boot.ci(means, conf = 0.95, type = "bca") 
  
  serra.do.mar_IUCN_lower_cis[[i+1]]<-mean.int.95.BCa$bca[1,4] 
  serra.do.mar_IUCN_upper_cis[[i+1]]<-mean.int.95.BCa$bca[1,5] 
  serra.do.mar_IUCN_means_boot[[i+1]] <- means$t0  
}


serra.do.mar_IUCN_means_boot<-as.data.frame(unlist(serra.do.mar_IUCN_means_boot))
names(serra.do.mar_IUCN_means_boot)[1]<-"mean"

serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 246, .before = 1)
serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 245, .before = 2) 
serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 187, .before = 4) 
serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 172, .before = 8) 
serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 171, .before = 14) 
serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 163, .before = 50)
serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 56, .before = 145)
serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 18, .before = 159)
serra.do.mar_IUCN_means_boot<-serra.do.mar_IUCN_means_boot %>% add_row(mean = 0) 

serra.do.mar_IUCN_lower_cis<-as.data.frame(unlist(serra.do.mar_IUCN_lower_cis))
names(serra.do.mar_IUCN_lower_cis)[1]<-"lower_95.ci"

serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 246, .before = 1) 
serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 245, .before = 2) 
serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 187, .before = 4) 
serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 172, .before = 8) 
serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 171, .before = 14) 
serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 163, .before = 50)
serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 56, .before = 145)
serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 18, .before = 159)
serra.do.mar_IUCN_lower_cis<-serra.do.mar_IUCN_lower_cis %>% add_row(lower_95.ci = 0) 

serra.do.mar_IUCN_upper_cis<-as.data.frame(unlist(serra.do.mar_IUCN_upper_cis))
names(serra.do.mar_IUCN_upper_cis)[1]<-"upper_95.ci"

serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 246, .before = 1) 
serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 245, .before = 2) 
serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 187, .before = 4) 
serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 172, .before = 8) 
serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 171, .before = 14) 
serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 163, .before = 50)
serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 56, .before = 145)
serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 18, .before = 159)
serra.do.mar_IUCN_upper_cis<-serra.do.mar_IUCN_upper_cis %>% add_row(upper_95.ci = 0) 

serra.do.mar_plant_survivors_IUCN_btstrped<-cbind(serra.do.mar_IUCN_means_boot, serra.do.mar_IUCN_upper_cis, serra.do.mar_IUCN_lower_cis)

serra.do.mar_plant_survivors_IUCN_btstrped$n_frugs_removed<-seq(from = 0, to = 173)

# clean

rm(means, mean.int.95.BCa, i, serra.do.mar_IUCN_lower_cis, serra.do.mar_IUCN_upper_cis, serra.do.mar_IUCN_means_boot, serra.do.mar_plant_survivors_IUCN, temp_serra.do.mar_IUCN)
```

##### Mata Caducifolia
Serra do Mar ecoregion sequential elimination of endangered frugivores per IUCN category, followed by bootstrapping.
```{r mata caducifolia IUCN based removals, cache = TRUE}

mata.caducifolia_robustness_vec_IUCN <- rep(NA, 1000)

mata.caducifolia_plant_survivors_vec_IUCN<- list()

for(j in 1:1000) {
mata.caducifolia_IUCN_s1 <- c(sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frug_IUCN == "CR")]),
                              sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frug_IUCN == "EN")]), 
                              sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frug_IUCN == "VU")]), 
                              sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frug_IUCN == "NT")]), 
                              sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frug_IUCN == "LC" & mata.caducifolia_frug_md$Frug_Population_Trend == "Decreasing")]),
                              sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frug_IUCN == "LC" & mata.caducifolia_frug_md$Frug_Population_Trend == "Unknown")]),
                              sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frug_IUCN == "LC" & mata.caducifolia_frug_md$Frug_Population_Trend == "Stable")]),
                              sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frug_IUCN == "LC" & mata.caducifolia_frug_md$Frug_Population_Trend == "Increasing")]))

mata.caducifolia.triggerlist.IUCN <- list()

  for(i in 1:length(mata.caducifolia_IUCN_s1)) {
    mata.caducifolia.triggerlist.IUCN[[i]] <- sample(mata.caducifolia_frug_md$Frugivore_Species[which(mata.caducifolia_frug_md$Frugivore_Species == mata.caducifolia_IUCN_s1[i])], length(which(mata.caducifolia_frug_md$Frugivore_Species == mata.caducifolia_IUCN_s1[i])))
  }

  mata.caducifolia.triggerlist.IUCN <- unlist(mata.caducifolia.triggerlist.IUCN)
  
  mata.caducifolia.triggerlist.IUCN <- as.character(mata.caducifolia.triggerlist.IUCN)
  
  #-----------------------------------------#
  
  mata.caducifolia.new.mat<-list()
  
  mata.caducifolia.new.mat[[1]]<-mat.mata.caducifolia
  
  for(i in 1:length(mata.caducifolia.triggerlist.IUCN)) {
    mata.caducifolia.mat <- mata.caducifolia.new.mat[[i]]
    mata.caducifolia.mat[ ,which(colnames(mata.caducifolia.mat) == mata.caducifolia.triggerlist.IUCN[i])]<-0
    mata.caducifolia.new.mat[[i+1]] <- mata.caducifolia.mat
  }
  
  mata.caducifolia.survivors.ll <-NULL
  
  mata.caducifolia.survivors.ll[[1]] <- nrow(mat.mata.caducifolia)
  
  for(i in 1:length(mata.caducifolia.new.mat)) {mata.caducifolia.survivors.ll[i] <- length(which(rowSums(mata.caducifolia.new.mat[[i]])>0))}
  
  mata.caducifolia_plant_survivors_vec_IUCN[[j]]<-mata.caducifolia.survivors.ll
  
  unlist(mata.caducifolia.survivors.ll)
  
  mata.caducifolia.robustness.ll <-(sum(unlist(mata.caducifolia.survivors.ll)))/((ncol(mat.mata.caducifolia))*(nrow(mat.mata.caducifolia)))
  
  mata.caducifolia_robustness_vec_IUCN[j] <- mata.caducifolia.robustness.ll
}

#extract survivor values into a workable form

mata.caducifolia_plant_survivors_vec_IUCN_copy <- mata.caducifolia_plant_survivors_vec_IUCN
mata.caducifolia_plant_survivors_IUCN_df<-as.data.frame(seq(from = 0, to = 84))
for(i in 1:length(mata.caducifolia_plant_survivors_vec_IUCN_copy)) {temp_mata.caducifolia_IUCN<-unlist(mata.caducifolia_plant_survivors_vec_IUCN_copy[[i]])
mata.caducifolia_plant_survivors_IUCN_df[,i]<-temp_mata.caducifolia_IUCN}

mata.caducifolia_plant_survivors_IUCN_mat<-as.matrix(mata.caducifolia_plant_survivors_IUCN_df)
mata.caducifolia_plant_survivors_IUCN_mat<-t(mata.caducifolia_plant_survivors_IUCN_mat)
mata.caducifolia_plant_survivors_IUCN<-as.data.frame(mata.caducifolia_plant_survivors_IUCN_mat)

# clean

rm(mata.caducifolia_plant_survivors_vec_IUCN_copy, mata.caducifolia_plant_survivors_IUCN_df, mata.caducifolia_plant_survivors_IUCN_mat, mata.caducifolia.robustness.ll,mata.caducifolia.survivors.ll, mata.caducifolia.new.mat, temp_mata.caducifolia_IUCN, mata.caducifolia.triggerlist.IUCN, mata.caducifolia_IUCN_s1, mata.caducifolia_plant_survivors_vec_IUCN, i, j)

```

```{r mata caducifolia iucn based removals bootstrapping, cache=TRUE}
mata.caducifolia_IUCN_means_boot<-list() #create empty list to store means

mata.caducifolia_IUCN_upper_cis<-list() #create empty list to store upper CI's

mata.caducifolia_IUCN_lower_cis<-list() #crate empty list to store lower CI's

mata.caducifolia_plant_survivors_IUCN <- mata.caducifolia_plant_survivors_IUCN[,-c(1, 2, 4, 5, 6, 22, 24, 77, 85)]


for(i in 1:length(mata.caducifolia_plant_survivors_IUCN)){
  
  means <- boot(mata.caducifolia_plant_survivors_IUCN[i], R = 1200, statistic = meanfun)
  
  mean.int.95.BCa <- boot.ci(means, conf = 0.95, type = "bca") 
  
  mata.caducifolia_IUCN_lower_cis[[i+1]]<-mean.int.95.BCa$bca[1,4] 
  mata.caducifolia_IUCN_upper_cis[[i+1]]<-mean.int.95.BCa$bca[1,5] 
  mata.caducifolia_IUCN_means_boot[[i+1]] <- means$t0  
}

mata.caducifolia_IUCN_means_boot<-as.data.frame(unlist(mata.caducifolia_IUCN_means_boot))
names(mata.caducifolia_IUCN_means_boot)[1]<-"mean"

mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 129, .before = 1)
mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 114, .before = 2) 
mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 110, .before = 4) 
mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 109, .before = 5) 
mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 109, .before = 6) 
mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 107, .before = 22)
mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 101, .before = 24)
mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 17, .before = 77)
mata.caducifolia_IUCN_means_boot<-mata.caducifolia_IUCN_means_boot %>% add_row(mean = 0) 

mata.caducifolia_IUCN_lower_cis<-as.data.frame(unlist(mata.caducifolia_IUCN_lower_cis))
names(mata.caducifolia_IUCN_lower_cis)[1]<-"lower_95.ci"

mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 129, .before = 1) 
mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 114, .before = 2) 
mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 110, .before = 4) 
mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 109, .before = 5) 
mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 109, .before = 6) 
mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 107, .before = 22)
mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 101, .before = 24)
mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 17, .before = 77)
mata.caducifolia_IUCN_lower_cis<-mata.caducifolia_IUCN_lower_cis %>% add_row(lower_95.ci = 0) 

mata.caducifolia_IUCN_upper_cis<-as.data.frame(unlist(mata.caducifolia_IUCN_upper_cis))
names(mata.caducifolia_IUCN_upper_cis)[1]<-"upper_95.ci"

mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 129, .before = 1) 
mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 114, .before = 2) 
mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 110, .before = 4) 
mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 109, .before = 5) 
mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 109, .before = 6) 
mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 107, .before = 22)
mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 101, .before = 24)
mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 17, .before = 77)
mata.caducifolia_IUCN_upper_cis<-mata.caducifolia_IUCN_upper_cis %>% add_row(upper_95.ci = 0) 

mata.caducifolia_plant_survivors_IUCN_btstrped<-cbind(mata.caducifolia_IUCN_means_boot, mata.caducifolia_IUCN_upper_cis, mata.caducifolia_IUCN_lower_cis)

mata.caducifolia_plant_survivors_IUCN_btstrped$n_frugs_removed<-seq(from = 0, to = 84)

# clean

rm(means, mean.int.95.BCa, i, mata.caducifolia_IUCN_lower_cis, mata.caducifolia_IUCN_upper_cis, mata.caducifolia_IUCN_means_boot, mata.caducifolia_plant_survivors_IUCN)

```
    
    
### Removal based on greatest to lowest body mass
Generate coextinction cascade that follows sequential removal of frugivore species from largest to smallest.

#### Biome-scale body-mass-based removal simulations
The following code chunk removed frugivores from largest to smallest body mass from the biome-scale network:
```{r biome-scale removal scenario of frugivores by descending body mass}
    biome_bodymass_triggerlist <- biome_frug_md %>% dplyr::arrange(desc(Frug_Body_Mass)) %>% dplyr::select(Frugivore_Species)
biome_bodymass_triggerlist <- unlist(biome_bodymass_triggerlist)
  #-----------------------------------------#
  biome_new.mat_bodymass<-list()
  biome_new.mat_bodymass[[1]]<-biome.mat
  for(i in 1:length(biome_bodymass_triggerlist)) {
    biome.mat.temp <- biome_new.mat_bodymass[[i]]
    biome.mat.temp[ ,which(colnames(biome.mat.temp) == biome_bodymass_triggerlist[i])]<-0
    biome_new.mat_bodymass[[i+1]] <- biome.mat.temp
  }
  biome_plant_survivors_bodymass <-NULL
  biome_plant_survivors_bodymass[[1]] <- nrow(biome.mat)
  for(i in 1:length(biome_new.mat_bodymass)) {biome_plant_survivors_bodymass[i] <- length(which(rowSums(biome_new.mat_bodymass[[i]])>0))} 
  
biome_robustness_bodymass <-(sum(unlist(biome_plant_survivors_bodymass)))/((ncol(biome.mat))*(nrow(biome.mat)))

# get output ready to join with others for graphing

biome_plant_survivors_bodymass <- as.data.frame(unlist(biome_plant_survivors_bodymass))

# make a frugivores removed column

biome_plant_survivors_bodymass$n_frugs_removed <- seq(from = 0, to = 321)

# rename survivor column

names(biome_plant_survivors_bodymass)[1]<-"n_plants_remaining"

# add removal scenario column
biome_plant_survivors_bodymass$scenario<-"descending_bodymass"

# clean

rm(i, biome_new.mat_bodymass, biome.mat.temp, biome_bodymass_triggerlist)

```

#### Ecoregion-scale body-mass-based removal simulations
Each of the following three code chunks removes frugivores from largest to smallest body mass per ecoregion:
```{r cerrado body-mass-based removal simulation}
 cerrado_bodymass_triggerlist <- cerrado_frug_md %>% dplyr::arrange(desc(Frug_Body_Mass)) %>% dplyr::select(Frugivore_Species)
cerrado_bodymass_triggerlist <- unlist(cerrado_bodymass_triggerlist)
  #-----------------------------------------#
  cerrado_new.mat_bodymass<-list()
  cerrado_new.mat_bodymass[[1]]<-mat.cerrado
  for(i in 1:length(cerrado_bodymass_triggerlist)) {
    mat.cerrado.temp <- cerrado_new.mat_bodymass[[i]]
    mat.cerrado.temp[ ,which(colnames(mat.cerrado.temp) == cerrado_bodymass_triggerlist[i])]<-0
    cerrado_new.mat_bodymass[[i+1]] <- mat.cerrado.temp
  }
  cerrado_plant_survivors_bodymass <-NULL
  cerrado_plant_survivors_bodymass[[1]] <- nrow(mat.cerrado)
  for(i in 1:length(cerrado_new.mat_bodymass)) {cerrado_plant_survivors_bodymass[i] <- length(which(rowSums(cerrado_new.mat_bodymass[[i]])>0))} 
  
cerrado_robustness_bodymass <-(sum(unlist(cerrado_plant_survivors_bodymass)))/((ncol(mat.cerrado))*(nrow(mat.cerrado)))

# get output ready to join with others for graphing

cerrado_plant_survivors_bodymass <- as.data.frame(unlist(cerrado_plant_survivors_bodymass))

# make a frugivores removed column

cerrado_plant_survivors_bodymass$n_frugs_removed <- seq(from = 0, to = 91)

# rename survivor column

names(cerrado_plant_survivors_bodymass)[1]<-"n_plants_remaining"

# add removal scenario column
cerrado_plant_survivors_bodymass$scenario<-"descending_bodymass"

# clean

rm(i, cerrado_new.mat_bodymass, mat.cerrado.temp, cerrado_bodymass_triggerlist)
```

```{r serra do mar body-mass-based removal simulation}
 serra.do.mar_bodymass_triggerlist <- serra.do.mar_frug_md %>% dplyr::arrange(desc(Frug_Body_Mass)) %>% dplyr::select(Frugivore_Species)
serra.do.mar_bodymass_triggerlist <- unlist(serra.do.mar_bodymass_triggerlist)
  #-----------------------------------------#
  serra.do.mar_new.mat_bodymass<-list()
  serra.do.mar_new.mat_bodymass[[1]]<-mat.serra.do.mar
  for(i in 1:length(serra.do.mar_bodymass_triggerlist)) {
    mat.serra.do.mar.temp <- serra.do.mar_new.mat_bodymass[[i]]
    mat.serra.do.mar.temp[ ,which(colnames(mat.serra.do.mar.temp) == serra.do.mar_bodymass_triggerlist[i])]<-0
    serra.do.mar_new.mat_bodymass[[i+1]] <- mat.serra.do.mar.temp
  }
  serra.do.mar_plant_survivors_bodymass <-NULL
  serra.do.mar_plant_survivors_bodymass[[1]] <- nrow(mat.serra.do.mar)
  for(i in 1:length(serra.do.mar_new.mat_bodymass)) {serra.do.mar_plant_survivors_bodymass[i] <- length(which(rowSums(serra.do.mar_new.mat_bodymass[[i]])>0))} 
  
serra.do.mar_robustness_bodymass <-(sum(unlist(serra.do.mar_plant_survivors_bodymass)))/((ncol(mat.serra.do.mar))*(nrow(mat.serra.do.mar)))

# get output ready to join with others for graphing

serra.do.mar_plant_survivors_bodymass <- as.data.frame(unlist(serra.do.mar_plant_survivors_bodymass))

# make a frugivores removed column

serra.do.mar_plant_survivors_bodymass$n_frugs_removed <- seq(from = 0, to = 173)

# rename survivor column

names(serra.do.mar_plant_survivors_bodymass)[1]<-"n_plants_remaining"

# add removal scenario column
serra.do.mar_plant_survivors_bodymass$scenario<-"descending_bodymass"

# clean

rm(i, serra.do.mar_new.mat_bodymass, mat.serra.do.mar.temp, serra.do.mar_bodymass_triggerlist)
```

```{r mata caducifolia body-mass-based removal simulation}
 mata.caducifolia_bodymass_triggerlist <- mata.caducifolia_frug_md %>% dplyr::arrange(desc(Frug_Body_Mass)) %>% dplyr::select(Frugivore_Species)
mata.caducifolia_bodymass_triggerlist <- unlist(mata.caducifolia_bodymass_triggerlist)
  #-----------------------------------------#
  mata.caducifolia_new.mat_bodymass<-list()
  mata.caducifolia_new.mat_bodymass[[1]]<-mat.mata.caducifolia
  for(i in 1:length(mata.caducifolia_bodymass_triggerlist)) {
    mat.mata.caducifolia.temp <- mata.caducifolia_new.mat_bodymass[[i]]
    mat.mata.caducifolia.temp[ ,which(colnames(mat.mata.caducifolia.temp) == mata.caducifolia_bodymass_triggerlist[i])]<-0
    mata.caducifolia_new.mat_bodymass[[i+1]] <- mat.mata.caducifolia.temp
  }
  mata.caducifolia_plant_survivors_bodymass <-NULL
  mata.caducifolia_plant_survivors_bodymass[[1]] <- nrow(mat.mata.caducifolia)
  for(i in 1:length(mata.caducifolia_new.mat_bodymass)) {mata.caducifolia_plant_survivors_bodymass[i] <- length(which(rowSums(mata.caducifolia_new.mat_bodymass[[i]])>0))} 
  
mata.caducifolia_robustness_bodymass <-(sum(unlist(mata.caducifolia_plant_survivors_bodymass)))/((ncol(mat.mata.caducifolia))*(nrow(mat.mata.caducifolia)))

# get output ready to join with others for graphing

mata.caducifolia_plant_survivors_bodymass <- as.data.frame(unlist(mata.caducifolia_plant_survivors_bodymass))

# make a frugivores removed column

mata.caducifolia_plant_survivors_bodymass$n_frugs_removed <- seq(from = 0, to = 84)

# rename survivor column

names(mata.caducifolia_plant_survivors_bodymass)[1]<-"n_plants_remaining"

# add removal scenario column
mata.caducifolia_plant_survivors_bodymass$scenario<-"descending_bodymass"

# clean

rm(i, mata.caducifolia_new.mat_bodymass, mat.mata.caducifolia.temp, mata.caducifolia_bodymass_triggerlist)
```


### Removal based on greatest to lowest degree
Generate coextinction cascades that follow sequential removal of frugivores that are the most to least connected
#### Biome-scale degree-based removal simulations
The following code chunk removes most to least connecte frugivores from the biome-scale network:
```{r biome-scale removal scenario of frugivores by descending degree}
    biome_degree_triggerlist <- biome_frug_md %>% dplyr::arrange(desc(Frugivore_degree)) %>% dplyr::select(Frugivore_Species)
biome_degree_triggerlist <- unlist(biome_degree_triggerlist)
  #-----------------------------------------#
  biome_new.mat_degree<-list()
  biome_new.mat_degree[[1]]<-biome.mat
  for(i in 1:length(biome_degree_triggerlist)) {
    biome.mat.temp <- biome_new.mat_degree[[i]]
    biome.mat.temp[ ,which(colnames(biome.mat.temp) == biome_degree_triggerlist[i])]<-0
    biome_new.mat_degree[[i+1]] <- biome.mat.temp
  }
  biome_plant_survivors_degree <-NULL
  biome_plant_survivors_degree[[1]] <- nrow(biome.mat)
  for(i in 1:length(biome_new.mat_degree)) {biome_plant_survivors_degree[i] <- length(which(rowSums(biome_new.mat_degree[[i]])>0))} 
  
biome_robustness_degree <-(sum(unlist(biome_plant_survivors_degree)))/((ncol(biome.mat))*(nrow(biome.mat)))

# get output ready to join with others for graphing

biome_plant_survivors_degree <- as.data.frame(unlist(biome_plant_survivors_degree))

# make a frugivores removed column

biome_plant_survivors_degree$n_frugs_removed <- seq(from = 0, to = 321)

# rename survivor column

names(biome_plant_survivors_degree)[1]<-"n_plants_remaining"

# add removal scenario column
biome_plant_survivors_degree$scenario<-"descending_degree"

# clean

rm(i, biome_new.mat_degree, biome.mat.temp, biome_degree_triggerlist)
```

#### Ecoregion-scale degree-based removal simulations

The following three code chunks remove the most to least conected frugivores from the ecoregion networks:

```{r cerrado degree-based removal simulation}
 cerrado_degree_triggerlist <- cerrado_frug_md %>% dplyr::arrange(desc(Frugivore_degree)) %>% dplyr::select(Frugivore_Species)
cerrado_degree_triggerlist <- unlist(cerrado_degree_triggerlist)
  #-----------------------------------------#
  cerrado_new.mat_degree<-list()
  cerrado_new.mat_degree[[1]]<-mat.cerrado
  for(i in 1:length(cerrado_degree_triggerlist)) {
    mat.cerrado.temp <- cerrado_new.mat_degree[[i]]
    mat.cerrado.temp[ ,which(colnames(mat.cerrado.temp) == cerrado_degree_triggerlist[i])]<-0
    cerrado_new.mat_degree[[i+1]] <- mat.cerrado.temp
  }
  cerrado_plant_survivors_degree <-NULL
  cerrado_plant_survivors_degree[[1]] <- nrow(mat.cerrado)
  for(i in 1:length(cerrado_new.mat_degree)) {cerrado_plant_survivors_degree[i] <- length(which(rowSums(cerrado_new.mat_degree[[i]])>0))} 
  
cerrado_robustness_degree <-(sum(unlist(cerrado_plant_survivors_degree)))/((ncol(mat.cerrado))*(nrow(mat.cerrado)))

# get output ready to join with others for graphing

cerrado_plant_survivors_degree <- as.data.frame(unlist(cerrado_plant_survivors_degree))

# make a frugivores removed column

cerrado_plant_survivors_degree$n_frugs_removed <- seq(from = 0, to = 91)

# rename survivor column

names(cerrado_plant_survivors_degree)[1]<-"n_plants_remaining"

# add removal scenario column
cerrado_plant_survivors_degree$scenario<-"descending_degree"

# clean

rm(i, cerrado_new.mat_degree, mat.cerrado.temp, cerrado_degree_triggerlist)
```

```{r serra do mar degree-based removal simulation}
 serra.do.mar_degree_triggerlist <- serra.do.mar_frug_md %>% dplyr::arrange(desc(Frugivore_degree)) %>% dplyr::select(Frugivore_Species)
serra.do.mar_degree_triggerlist <- unlist(serra.do.mar_degree_triggerlist)
  #-----------------------------------------#
  serra.do.mar_new.mat_degree<-list()
  serra.do.mar_new.mat_degree[[1]]<-mat.serra.do.mar
  for(i in 1:length(serra.do.mar_degree_triggerlist)) {
    mat.serra.do.mar.temp <- serra.do.mar_new.mat_degree[[i]]
    mat.serra.do.mar.temp[ ,which(colnames(mat.serra.do.mar.temp) == serra.do.mar_degree_triggerlist[i])]<-0
    serra.do.mar_new.mat_degree[[i+1]] <- mat.serra.do.mar.temp
  }
  serra.do.mar_plant_survivors_degree <-NULL
  serra.do.mar_plant_survivors_degree[[1]] <- nrow(mat.serra.do.mar)
  for(i in 1:length(serra.do.mar_new.mat_degree)) {serra.do.mar_plant_survivors_degree[i] <- length(which(rowSums(serra.do.mar_new.mat_degree[[i]])>0))} 
  
serra.do.mar_robustness_degree <-(sum(unlist(serra.do.mar_plant_survivors_degree)))/((ncol(mat.serra.do.mar))*(nrow(mat.serra.do.mar)))

# get output ready to join with others for graphing

serra.do.mar_plant_survivors_degree <- as.data.frame(unlist(serra.do.mar_plant_survivors_degree))

# make a frugivores removed column

serra.do.mar_plant_survivors_degree$n_frugs_removed <- seq(from = 0, to = 173)

# rename survivor column

names(serra.do.mar_plant_survivors_degree)[1]<-"n_plants_remaining"

# add removal scenario column
serra.do.mar_plant_survivors_degree$scenario<-"descending_degree"

# clean

rm(i, serra.do.mar_new.mat_degree, mat.serra.do.mar.temp, serra.do.mar_degree_triggerlist)
```

```{r mata caducifolia degree-based removal simulation}
 mata.caducifolia_degree_triggerlist <- mata.caducifolia_frug_md %>% dplyr::arrange(desc(Frugivore_degree)) %>% dplyr::select(Frugivore_Species)
mata.caducifolia_degree_triggerlist <- unlist(mata.caducifolia_degree_triggerlist)
  #-----------------------------------------#
  mata.caducifolia_new.mat_degree<-list()
  mata.caducifolia_new.mat_degree[[1]]<-mat.mata.caducifolia
  for(i in 1:length(mata.caducifolia_degree_triggerlist)) {
    mat.mata.caducifolia.temp <- mata.caducifolia_new.mat_degree[[i]]
    mat.mata.caducifolia.temp[ ,which(colnames(mat.mata.caducifolia.temp) == mata.caducifolia_degree_triggerlist[i])]<-0
    mata.caducifolia_new.mat_degree[[i+1]] <- mat.mata.caducifolia.temp
  }
  mata.caducifolia_plant_survivors_degree <-NULL
  mata.caducifolia_plant_survivors_degree[[1]] <- nrow(mat.mata.caducifolia)
  for(i in 1:length(mata.caducifolia_new.mat_degree)) {mata.caducifolia_plant_survivors_degree[i] <- length(which(rowSums(mata.caducifolia_new.mat_degree[[i]])>0))} 
  
mata.caducifolia_robustness_degree <-(sum(unlist(mata.caducifolia_plant_survivors_degree)))/((ncol(mat.mata.caducifolia))*(nrow(mat.mata.caducifolia)))

# get output ready to join with others for graphing

mata.caducifolia_plant_survivors_degree <- as.data.frame(unlist(mata.caducifolia_plant_survivors_degree))

# make a frugivores removed column

mata.caducifolia_plant_survivors_degree$n_frugs_removed <- seq(from = 0, to = 84)

# rename survivor column

names(mata.caducifolia_plant_survivors_degree)[1]<-"n_plants_remaining"

# add removal scenario column
mata.caducifolia_plant_survivors_degree$scenario<-"descending_degree"

# clean

rm(i, mata.caducifolia_new.mat_degree, mat.mata.caducifolia.temp, mata.caducifolia_degree_triggerlist)
```

### Figures for analysis 3 illustrating coextinction cascades following each removal scenario

Each network (biome, plus each ecoregion) has a full version and a zoomed in version of a figure showing the plant coextinctions following the different removal scenarios. The zoomed in versions are enlargements of the graph portions that only show up until the last high risk frugivore (greater than 'least concern' category) is removed from the network.

#### Join data from removal scenarios for easier graphing
The resulting coextinction data from the simulations in section 4.4 need to be collected and merged for easier graphing. 
```{r merge datasets for graphing starting with biome data}

# BIOME:

# biome-scale I need to join biome_plant_survivors_random_btstrped, biome_plant_survivors_IUCN_btstrped, biome_plant_survivors_bodymass, biome_plant_survivors_degree

# different column names exist and need to be unified: random and IUCN data has upper and lower CI data, while the degree and body mass scenarios do not. Just duplicate the plant survivor columns in those two dataframes into 'CI' columns so that the dataframe column names and numbers match up and are mergeable. 

# for my random and iucn scenarios add scenario column, rename 'mean' to 'n_plants_remaining'
biome_plant_survivors_random_btstrped$scenario <- "random"
names(biome_plant_survivors_random_btstrped)[1] <- "n_plants_remaining"
biome_plant_survivors_IUCN_btstrped$scenario <- "descending_endangerment"
names(biome_plant_survivors_IUCN_btstrped)[1] <- "n_plants_remaining"

# for my bodymass and degree based removal data, add the filler CI interval columns that are just duplicates of the raw values bc these are not scenarios that can vary in outcome
biome_plant_survivors_bodymass$upper_95.ci<-biome_plant_survivors_bodymass$n_plants_remaining
biome_plant_survivors_bodymass$lower_95.ci<-biome_plant_survivors_bodymass$n_plants_remaining
biome_plant_survivors_degree$upper_95.ci<-biome_plant_survivors_degree$n_plants_remaining
biome_plant_survivors_degree$lower_95.ci<-biome_plant_survivors_degree$n_plants_remaining

# join

biome_plant_survivors <- rbind(biome_plant_survivors_random_btstrped, biome_plant_survivors_IUCN_btstrped, biome_plant_survivors_bodymass, biome_plant_survivors_degree)

# clean

rm(biome_plant_survivors_bodymass, biome_plant_survivors_degree, biome_plant_survivors_IUCN_btstrped, biome_plant_survivors_random_btstrped)
```

```{r rbind the ecoregion coexinction data for graphing}

# same process as above, but also add ecoregion column to all

# cerrado

cerrado_plant_survivors_random_btstrped$scenario <- "random"
cerrado_plant_survivors_random_btstrped$ecoregion <- "cerrado"
names(cerrado_plant_survivors_random_btstrped)[1] <- "n_plants_remaining"
cerrado_plant_survivors_IUCN_btstrped$scenario <- "descending_endangerment"
cerrado_plant_survivors_IUCN_btstrped$ecoregion <- "cerrado"
names(cerrado_plant_survivors_IUCN_btstrped)[1] <- "n_plants_remaining"

cerrado_plant_survivors_bodymass$upper_95.ci<-cerrado_plant_survivors_bodymass$n_plants_remaining
cerrado_plant_survivors_bodymass$lower_95.ci<-cerrado_plant_survivors_bodymass$n_plants_remaining
cerrado_plant_survivors_degree$upper_95.ci<-cerrado_plant_survivors_degree$n_plants_remaining
cerrado_plant_survivors_degree$lower_95.ci<-cerrado_plant_survivors_degree$n_plants_remaining

cerrado_plant_survivors_bodymass$ecoregion<-"cerrado"
cerrado_plant_survivors_degree$ecoregion<-"cerrado"

# join

cerrado_plant_survivors <- rbind(cerrado_plant_survivors_random_btstrped, cerrado_plant_survivors_IUCN_btstrped, cerrado_plant_survivors_bodymass, cerrado_plant_survivors_degree)

#serra do mar

serra.do.mar_plant_survivors_random_btstrped$scenario <- "random"
serra.do.mar_plant_survivors_random_btstrped$ecoregion <- "serra.do.mar"
names(serra.do.mar_plant_survivors_random_btstrped)[1] <- "n_plants_remaining"
serra.do.mar_plant_survivors_IUCN_btstrped$scenario <- "descending_endangerment"
serra.do.mar_plant_survivors_IUCN_btstrped$ecoregion <- "serra.do.mar"
names(serra.do.mar_plant_survivors_IUCN_btstrped)[1] <- "n_plants_remaining"

serra.do.mar_plant_survivors_bodymass$upper_95.ci<-serra.do.mar_plant_survivors_bodymass$n_plants_remaining
serra.do.mar_plant_survivors_bodymass$lower_95.ci<-serra.do.mar_plant_survivors_bodymass$n_plants_remaining
serra.do.mar_plant_survivors_degree$upper_95.ci<-serra.do.mar_plant_survivors_degree$n_plants_remaining
serra.do.mar_plant_survivors_degree$lower_95.ci<-serra.do.mar_plant_survivors_degree$n_plants_remaining

serra.do.mar_plant_survivors_bodymass$ecoregion<-"serra.do.mar"
serra.do.mar_plant_survivors_degree$ecoregion<-"serra.do.mar"

# join

serra.do.mar_plant_survivors <- rbind(serra.do.mar_plant_survivors_random_btstrped, serra.do.mar_plant_survivors_IUCN_btstrped, serra.do.mar_plant_survivors_bodymass, serra.do.mar_plant_survivors_degree)

# mata caducifolia

mata.caducifolia_plant_survivors_random_btstrped$scenario <- "random"
mata.caducifolia_plant_survivors_random_btstrped$ecoregion <- "mata.caducifolia"
names(mata.caducifolia_plant_survivors_random_btstrped)[1] <- "n_plants_remaining"
mata.caducifolia_plant_survivors_IUCN_btstrped$scenario <- "descending_endangerment"
mata.caducifolia_plant_survivors_IUCN_btstrped$ecoregion <- "mata.caducifolia"
names(mata.caducifolia_plant_survivors_IUCN_btstrped)[1] <- "n_plants_remaining"

mata.caducifolia_plant_survivors_bodymass$upper_95.ci<-mata.caducifolia_plant_survivors_bodymass$n_plants_remaining
mata.caducifolia_plant_survivors_bodymass$lower_95.ci<-mata.caducifolia_plant_survivors_bodymass$n_plants_remaining
mata.caducifolia_plant_survivors_degree$upper_95.ci<-mata.caducifolia_plant_survivors_degree$n_plants_remaining
mata.caducifolia_plant_survivors_degree$lower_95.ci<-mata.caducifolia_plant_survivors_degree$n_plants_remaining

mata.caducifolia_plant_survivors_bodymass$ecoregion<-"mata.caducifolia"
mata.caducifolia_plant_survivors_degree$ecoregion<-"mata.caducifolia"

# join

mata.caducifolia_plant_survivors <- rbind(mata.caducifolia_plant_survivors_random_btstrped, mata.caducifolia_plant_survivors_IUCN_btstrped, mata.caducifolia_plant_survivors_bodymass, mata.caducifolia_plant_survivors_degree)

# join them all

ecoregion_coextinctions <- rbind(cerrado_plant_survivors, serra.do.mar_plant_survivors, mata.caducifolia_plant_survivors)

# clean

# rm(cerrado_plant_survivors_random_btstrped, cerrado_plant_survivors_IUCN_btstrped, cerrado_plant_survivors_bodymass, cerrado_plant_survivors_degree, cerrado_plant_survivors, serra.do.mar_plant_survivors_random_btstrped, serra.do.mar_plant_survivors_IUCN_btstrped, serra.do.mar_plant_survivors_bodymass, serra.do.mar_plant_survivors_degree, serra.do.mar_plant_survivors,mata.caducifolia_plant_survivors_random_btstrped, mata.caducifolia_plant_survivors_IUCN_btstrped, mata.caducifolia_plant_survivors_bodymass, mata.caducifolia_plant_survivors_degree, mata.caducifolia_plant_survivors) 
```

#### Now make the figures with all the joined simluation data
Biome-scale coextinction figure, showing (a) the full network for each removal scenario until all frugivores have been removed and (b) an enlargement of the rectangle in (a) showing the network up until all frugivores at high risk of extinction are removed, illustrating approximately a quarter of the network's tree species would be left without dispersers. This is followed by the ecoregion scale figures with corresponding enlargements of subsets of networks showing the endangered frugivore removals and predicted plant coextinctions (plots c-h).

```{r biome full coextinction plot}

biome_plot1 <- biome_plant_survivors %>%
  
  mutate(scenario = factor(scenario, levels = c("descending_degree", "descending_bodymass", "descending_endangerment", "random" ))) %>%
  
  ggplot(aes(x = n_frugs_removed, y = n_plants_remaining, group = scenario, color = scenario, linetype = scenario)) + 
  
  geom_line(size=0.9) +  scale_linetype_manual(values=c(3,2,1,4), labels = c("Most-to-least connected", "Descending body mass", "Descending risk of extinction", "Random")) + 
  
  theme_bw() + theme(panel.grid.minor = element_blank()) + 
  
  labs(y="# plants with extant dispersers", x = "# frugivore species lost") + 
  
  theme(axis.text = element_text(size = 10, color = "black")) +
  
  theme(axis.title = element_text(size = 10)) + 
  
  scale_color_manual(values = c("chocolate3", "cyan4", "darkred", "gray"), labels = c("Most-to-least connected", "Descending body mass", "Descending risk of extinction", "Random")) + 
  
  theme(legend.title = element_blank()) + 
  
  theme(legend.position = "none") +
  
  labs(tag = "(a)") 

# annotate zoom with endangerment labels

biome_plot1_zoom <- biome_plot1 + 
  
  ylim(550, 786) + xlim(0, 50) + 
  
  labs(tag = "(b)") + 
  
  annotate(geom = "segment", x = 5, y = 775, xend = 5, yend = 734, arrow = arrow(length = unit(1.2, "mm"), type = "closed")) + 
  
  annotate(geom = "text", x = 5, y =786, label = "CR", size = 3) +
  
  annotate(geom = "segment", x = 15, y = 775, xend = 15, yend = 630, arrow = arrow(length = unit(1.2, "mm"), type = "closed")) + 
  
  annotate(geom = "text", x = 15, y = 786, label = "EN", size = 3) + 
  
  annotate(geom = "segment", x = 25, y = 775, xend = 25, yend = 599, arrow = arrow(length = unit(1.2, "mm"), type = "closed")) + 
  
  annotate(geom = "text", x = 25, y = 786, label = "VU", size = 3) + 
  
  annotate(geom = "segment", x = 44, y = 775, xend = 44, yend = 575, arrow = arrow(length = unit(1.2, "mm"), type = "closed")) + 
  
  annotate(geom = "text", x = 44, y =786, label = "NT", size = 3) + 
  
  labs(title = "Enlargement of loss of at-risk frugivores") + theme(plot.title = element_text(size = 11))

# biome_plot1_zoom

# add rectangle of area to zoom in on (if added first, it shows up in the zoom version too)

biome_plot2 <- biome_plot1 + theme(legend.position="none") + 
  geom_rect(mapping = aes (xmin = -5, xmax=50, ymin = 540, ymax=795), fill = alpha(NA, 0), linetype = 1, color = "black", size = 0.3) + labs(title = "Biome-scale network decay\nunder different frugivore loss scenarios") + theme(plot.title = element_text(size = 11))

# biome_plot2

```
Above code chunk creates plot(s) for biome (full network plot + zoomed in area of losing only endangered frugivores). No plot displayed here - see panel at end of section.

```{r cerrado coextinction graphs}

# Cerrado full plot, raw values (not proportions, which are also plotted below)

cerrado_plot1 <- ecoregion_coextinctions %>%
  mutate(scenario = factor(scenario, levels = c("descending_degree",
                                                "descending_bodymass",
                                                "descending_endangerment", 
                                                "random" ))) %>% # put removal type in descending order of anticipated worst-case scenarios
  
  filter(ecoregion == "cerrado") %>% # isolate ecoregion
  
  ggplot(aes(x = n_frugs_removed, y = n_plants_remaining, 
             group = scenario, color = scenario, linetype = scenario)) +
  
  geom_line(size=0.9) + # adjust line size
  
  scale_linetype_manual(values=c(3,2,1,4), # specify lines so EN one is solid
                        labels = c("Most-to-least connected", "Descending body mass",
                                   "Descending risk of extinction", "Random")) +
  
  # specify simple theme without legend or legend title (will add legend w/ggarrange in a later chunk)
  theme_bw() + theme(panel.grid.minor = element_blank()) + 
  
  theme(legend.title = element_blank()) +
  
    theme(legend.position = "none") +
  
  labs(y="# plants with extant dispersers", x = "# frugivore species lost") + # name axes
  
  theme(axis.text = element_text(size = 10, color = "black")) +
  
  theme(axis.title = element_text(size = 10)) + # enlarge axis numbers and text
  
  scale_color_manual(values = c("chocolate3", "cyan4", "darkred", "gray"), labels = c("Most-to-least connected", "Descending body mass", "Descending risk of extinction", "Random")) + # manually add colors I want - try to make it color blind friendly and allow endangerment status line to stand out
  
  labs(tag = "(c)") + labs(title = "Ecoregion-scale: cerrado") + 
  
  theme(plot.title = element_text(size = 11)) 


# cerrado_plot1

# -- # 
# Next step: make enlarged section of above plot
# -- #

# Now create enlargement of portion of above plot up to point at which all endangered frugivores have been removed
# Annotate the zoomed in version with endangerment labels

cerrado_plot1_zoom <- cerrado_plot1 + ylim(35,57) + xlim(0, 5) + 

labs(tag = "(d)") + theme(legend.title = element_blank()) +
  
  annotate(geom = "segment", x = 1, y = 56, xend = 1, yend = 52, 
          arrow = arrow(length = unit(1.2, "mm"), type = "closed")) + 
  
  annotate(geom = "text", x = 1, y =57, label = "CR", size = 3) + 
  
  annotate(geom = "segment", x = 2, y = 56, xend = 2, yend = 38, 
          arrow = arrow(length = unit(1.2, "mm"), type = "closed")) +
  
  annotate(geom = "text", x = 2, y =57, label = "EN", size = 3) + # no NT in cerrado
  
  annotate(geom = "segment", x = 3, y = 56, xend = 3, yend = 38, 
          arrow = arrow(length = unit(1.2, "mm"), type = "closed")) + 

 annotate(geom = "text", x = 3, y =57, label = "VU", size = 3) + 
  
  labs(title = "Enlargement") + theme(plot.title = element_text(size = 11))

# cerrado_plot1_zoom

# -- # next step: add rectangle over area that gets enlarged

cerrado_plot2 <- cerrado_plot1 + 
  
  theme(legend.position="none") + theme(legend.title = element_blank()) + # no legend needed yet
  geom_rect(mapping = aes (xmin = -1, xmax=6, ymin = 34, ymax=57), fill = alpha(NA, 0), linetype = 1, color = "black", size = 0.3) + 
  labs(title = "Ecoregion-scale: cerrado") +
  theme(plot.title = element_text(size = 11)) # specify borders, color, and fill (transparent, alpha = 0), and linetype of rectangle

# cerrado_plot2 

```

Above code chunk creates plot(s) for cerrado (full network plot + zoomed in area of losing only endangered frugivores). No plot displayed here - see panel at end of section.

```{r mata caducifolia ecoregion coextinction graphs}

# Repeat with mata caducifolia
# See cerrado code chunk for annotations on graphing

mata.caducifolia_plot1 <- ecoregion_coextinctions %>%
  
  mutate(scenario = factor(scenario, levels = c("descending_degree",
                                                "descending_bodymass",
                                                "descending_endangerment", 
                                                "random" ))) %>% 
  
  filter(ecoregion == "mata.caducifolia") %>% 
  
  ggplot(aes(x = n_frugs_removed, y = n_plants_remaining, 
             group = scenario, color = scenario, linetype = scenario)) +
  
  geom_line(size=0.9) + 
  
  scale_linetype_manual(values=c(3,2,1,4), 
                        labels = c("Most-to-least connected", "Descending body mass",
                                   "Descending risk of extinction", "Random")) + 
  
  theme_bw() + theme(panel.grid.minor = element_blank()) + 
  
  theme(legend.title = element_blank())+
  
  labs(y="# plants with extant dispersers", x = "# frugivore species lost") + 
  
  theme(axis.text = element_text(size = 10, color = "black")) +
  
  theme(axis.title = element_text(size = 10)) + 
  
  scale_color_manual(values = c("chocolate3", "cyan4", "darkred", "gray"), labels = c("Most-to-least connected", "Descending body mass", "Descending risk of extinction", "Random")) + 
  
  theme(legend.position = "none") + 
  
  labs(tag = "(e)") +
  
  labs(title = "Ecoregion-scale: mata caducifolia") + theme(plot.title = element_text(size = 11))


# mata.caducifolia_plot1 


# -- # 
# Next step: add rectangle over area that gets enlarged
# -- #


mata.caducifolia_plot2 <- mata.caducifolia_plot1 + 
  theme(legend.position="none") +
  geom_rect(mapping = aes (xmin = -1, xmax= 7.5, ymin = 102, ymax=133),
            fill = alpha(NA, 0), linetype = 1, color = "black", size = 0.3) + 
  labs(tag="(e)") 


# mata.caducifolia_plot2 


# -- #
# Next step: enlarge it and annotate it
# -- #

mata.caducifolia_plot1_zoom <- mata.caducifolia_plot1 + 
  
ylim(106, 131) + xlim(0, 7) +
  
 labs(tag = "(f)") +
  
 annotate(geom = "segment", x = 1, y = 130, 
          xend = 1, yend = 114, 
         arrow = arrow(length = unit(1.2, "mm"), type = "closed")) +  
  
  annotate(geom = "text", x = 1, y = 131, label = "CR", size = 3) + 
  
  annotate(geom = "segment", x = 3, y = 130, 
          xend = 3, yend = 110, 
         arrow = arrow(length = unit(1.2, "mm"), type = "closed")) + 
  
  annotate(geom = "text", x = 3, y = 131, label = "EN", size = 3) + 
  
  annotate(geom = "segment", x = 4, y = 130, 
          xend = 4, yend = 109, 
         arrow = arrow(length = unit(1.2, "mm"), type = "closed")) +  
  
  annotate(geom = "text", x = 4, y = 131, label = "VU", size = 3) + 
  
  annotate(geom = "segment", x = 5, y = 130, 
          xend = 5, yend = 109, 
         arrow = arrow(length = unit(1.2, "mm"), type = "closed")) +
  
  annotate(geom = "text", x = 5, y = 131, label = "NT", size = 3) + 
  
  labs(title = "Enlargement") + theme(plot.title = element_text(size = 11))
  

# mata.caducifolia_plot1_zoom 

```

Above code chunk creates plot(s) for mata caducifolia (full network plot + zoomed in area of losing only endangered frugivores). No plot displayed here - see panel at end of section.

```{r serra do mar ecoregion coextinction graphs}

# Serra do Mar full plot
# For code annotations, see cerrado coextinction graph chunk above

serra.do.mar_plot1 <- ecoregion_coextinctions %>%
  
  mutate(scenario = factor(scenario, levels = c("descending_degree",
                                                "descending_bodymass",
                                                "descending_endangerment", 
                                                "random" ))) %>% 
  filter(ecoregion == "serra.do.mar") %>% 
  
  ggplot(aes(x = n_frugs_removed, y = n_plants_remaining, 
             group = scenario, color = scenario, linetype = scenario)) +
  
  geom_line(size=0.9) + 
  
  scale_linetype_manual(values=c(3,2,1,4), 
                        labels = c("Most-to-least connected", "Descending body mass",
                                   "Descending risk of extinction", "Random")) +
  theme_bw() + theme(panel.grid.minor = element_blank()) + 
  
  theme(legend.title = element_blank()) +
  
  labs(y="# plants with extant dispersers", x = "# frugivore species lost") + 
  
  theme(axis.text = element_text(size = 10, color = "black")) +
  
  theme(axis.title = element_text(size = 10)) +
  
  scale_color_manual(values = c("chocolate3", "cyan4", "darkred", "gray"), labels = c("Most-to-least connected", "Descending body mass", "Descending risk of extinction", "Random")) +
  
  theme(legend.position = "none") + 
  
  labs(tag = "(g)")


# serra.do.mar_plot1 


# -- # 
# Next step: add rectangle over area that gets enlarged
# -- #


serra.do.mar_plot2 <- serra.do.mar_plot1 + 
  
  theme(legend.position="none") +
  
  geom_rect(mapping = aes (xmin = -2, xmax= 16, ymin = 160, ymax=255), 
            fill = alpha(NA, 0), linetype = 1, color = "black", size = 0.3) + 
  
  labs(tag="(g)") + 
  
  labs(title = "Ecoregion-scale: Serra do Mar") + theme(plot.title = element_text(size = 11))


# serra.do.mar_plot2 


# -- #
# Next step: enlarge it and annotate it
# -- #

serra.do.mar_plot1_zoom <- serra.do.mar_plot1 + 
  
ylim(120, 256) + xlim(0, 18) +
  
 labs(tag = "(h)") +
  
 annotate(geom = "segment", x = 1, y = 251, 
          xend = 1, yend = 245, 
         arrow = arrow(length = unit(1.2, "mm"), type = "closed")) +  
  
  annotate(geom = "text", x = 1, y = 256, label = "CR", size = 3) + 
  
  annotate(geom = "segment", x = 3, y = 251, 
          xend = 3, yend = 187, 
         arrow = arrow(length = unit(1.2, "mm"), type = "closed")) + 
  
  annotate(geom = "text", x = 3, y = 256, label = "EN", size = 3) + 
  
  annotate(geom = "segment", x = 7, y = 251, 
          xend = 7, yend = 172, 
         arrow = arrow(length = unit(1.2, "mm"), type = "closed")) +  
  
  annotate(geom = "text", x = 7, y = 256, label = "VU", size = 3) + 
  
  annotate(geom = "segment", x = 13, y = 251, 
          xend = 13, yend = 171, 
         arrow = arrow(length = unit(1.2, "mm"), type = "closed")) +
  
  annotate(geom = "text", x = 13, y = 256, label = "NT", size = 3) + 
  
  labs(title = "Enlargement") + theme(plot.title = element_text(size = 11))
  

# serra.do.mar_plot1_zoom

```

Above code chunk creates plot(s) for Serra do Mar (full network plot + zoomed in area of losing only endangered frugivores). No plot displayed here - see panel at end of section.

```{r make ecoregion coextinction panel figure and save, fig.height = 12, warning=FALSE}

coextinction_panel <- ggarrange(biome_plot2, biome_plot1_zoom, cerrado_plot2, cerrado_plot1_zoom, mata.caducifolia_plot2, mata.caducifolia_plot1_zoom, serra.do.mar_plot2, serra.do.mar_plot1_zoom, ncol = 2, nrow = 4, common.legend = TRUE)

coextinction_panel

#ggsave(coextinction_panel, file = "plots/coextinctions_panel.pdf", units = "in", width = 8.5, height = 11, dpi = 400)

#ggsave(coextinction_panel, file = "plots/coextinctions_panel.png", units = "in", width = 8.5, height = 11, dpi = 400)

```

## Analysis 4: Investigate what might drive steep coextinction cascade following endangered frugivore removals - are specialist trees relying on endangered frugivores?

### Analysis 4: Data overview - examine plant data, what proportion of trees w/degrees of only 1-5 (specialists) rely on endangered frugivores?

First start with looking at some histograms...

#### Plant degree data distribution

Make histograms to look at plant degree distributions in the different regions/biome

```{r histograms to look at plant degree distributions, message=FALSE, warning=FALSE}

biome_plant_hist <- ggplot(data = biome_plant_md, aes(x = Plant_degree)) +
  geom_histogram(color = "black", fill = "darkgreen", bins = 60) + 
  theme_classic() + labs(y="Count", x = "Degree") +
  ggtitle("Biome-scale plant degree distribution") 

serra.do.mar_plant_hist <- ggplot(data = serra.do.mar_plant_md, aes(x = Plant_degree)) +
  geom_histogram(color = "black", fill = "lightblue") + 
  theme_classic() + labs(y="Count", x = "Degree") + 
  ggtitle("Serra do Mar plant degree \ndistribution") 


cerrado_plant_hist<-ggplot(data = cerrado_plant_md, aes(x = Plant_degree)) +
  geom_histogram(color = "black", fill = "tan") + 
  theme_classic() + labs(y="Count", x = "Degree") + 
  ggtitle("Cerrado plant degree distribution") 


mata.caducifolia_plant_hist<-ggplot(data = mata.caducifolia_plant_md, aes(x = Plant_degree)) +
  geom_histogram(color = "black", fill = "violet") + 
  theme_classic() + labs(y="Count", x = "Degree") + 
  ggtitle("Mata caducifolia plant degree \ndistribution")

ggarrange(biome_plant_hist, serra.do.mar_plant_hist, cerrado_plant_hist, mata.caducifolia_plant_hist)

```

  All have right skew, with a few super generalist trees but many with less than 10 or 20 frugivore partners. 

#### Proportions of specialist trees relying on endangered frugivores
To get an idea for what might be driving the trend seen in the coextinction simulations, we want to know what trees are relying on the higher risk frugivores as disperser partners in this network. 
  This is where the data used in Table 1 in the paper is calculated.

##### Biome-scale Network
How many specialist trees are dispersed by only 1 frugivore in the biome network?

```{r how many tree species have degree of 1 in the biome scale network}

biome_plants_1 <- biome_interaction_md %>%
  filter(Plant_degree == 1, .keep_all = TRUE)

length(unique(biome_plants_1$Plant_Species))

biome_plants_1_frugs <- biome_plants_1 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

names(biome_plants_1_frugs)[3] <-"Frugivore_Species" #rename

```

How many of those are dispersed only by endangered frugivores?

```{r how many trees with degree of 1 and are dispersed only by endangered frugivores in the biome scale network}
#knock out the species of low endangerment risk
biome_plants_1_noLC <- biome_plants_1_frugs %>%
  filter(Frug_IUCN != "LC")

biome_plants_1_noLC_counts <- biome_plants_1_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

#only the single row occurrences tell me which plant species actually ONLY had endangered frugivores as their disperser
length(biome_plants_1_noLC_counts$`n()`[which(biome_plants_1_noLC_counts$`n()` == 1)])
# 156 specialist biome_biome_plants only dispersed by endangered animals
# this is out of 285 total specialist plants, i.e. 156/285 = 54.7%
```

How many trees are only dispersed by 2 frugivores in the biome network? 

```{r how many trees with a degree of 2 exist in the biome scale network}

biome_plants_2 <- biome_interaction_md %>%
  filter(Plant_degree ==2, .keep_all = TRUE)

length(unique(biome_plants_2$Plant_Species))

# 120 tree species

```

How many tree species with a degree of 2 are dispersed only by endangered frugivores in the biome network?

```{r how many trees with degree of 2 are only dispersed by endangered frugivores in the biome scale network}

biome_plants_2_frugIUCN <- biome_plants_2 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

biome_plants_2_frugIUCN_noLC <- biome_plants_2_frugIUCN %>%
  filter(Frug_IUCN != "LC")

counts <- biome_plants_2_frugIUCN_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

# again, going by row number, we are interested in the trees that have only two observations (rows) and of which both of those rows/observations are of interactions with endangered frugivores

length(counts$`n()`[which(counts$`n()` == 2)])

# 37 tree species of degree 2 are only connected to endangered frugivores
# 120 tree species in total that have degree 2

```

How many trees are dispersed by only 3 frugivores in the biome network?

```{r how many trees with degree of 3 in the biome scale network}

biome_plants_3 <- biome_interaction_md %>%
  filter(Plant_degree == 3, .keep_all = TRUE)

length(unique(biome_plants_3$Plant_Species))

#55 

```

How many of the trees with a degree of 3 are dispersed only by endangered frugivores in the biome network?

```{r how many trees with degree of 3 only dispersed by endangered frugivores in the biome scale network}

biome_plants_3_frugIUCN <- biome_plants_3 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

biome_plants_3_noLC <- biome_plants_3_frugIUCN %>%
  filter(Frug_IUCN != "LC")

biome_plants_3_noLC_counts <- biome_plants_3_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(biome_plants_3_noLC_counts$`n()`[which(biome_plants_3_noLC_counts$`n()` == 3)])

```

How many trees are dispersed by 4 frugivores in the biome network?

```{r how many trees species have a degree of 4 in the biome scale network}

biome_plants_4 <- biome_interaction_md %>%
  filter(Plant_degree == 4, .keep_all = TRUE)

length(unique(biome_plants_4$Plant_Species))

```
How many of the trees with a degree of 4 are dispersed only by endangered frugivores in the biome network?

```{r how many trees with degree of 4 only dispersed by endangered frugs in the biome network}

biome_plants_4_frugs <- biome_plants_4 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

biome_plants_4_noLC <- biome_plants_4_frugs %>%
  filter(Frug_IUCN != "LC")

biome_plants_4_noLC_counts <- biome_plants_4_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(biome_plants_4_noLC_counts$`n()`[which(biome_plants_4_noLC_counts$`n()` == 4)])

# 5 with degree 4 that are connected only to end frug

```

How many tree species in the biome network have a degree of 5?

```{r how many trees with degree of 5 in the biome network}

biome_plants_5 <- biome_interaction_md %>%
  filter(Plant_degree == 5, .keep_all = TRUE)

length(unique(biome_plants_5$Plant_Species))

```

How many tree species with a degree of 5 are dispersed only by endangered frugivores in the biome network?

```{r how many trees with degree of 5 are only dispersed by endangered frugivores in the biome network}

biome_plants_5_frugs <- biome_plants_5 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

biome_plants_5_noLC <- biome_plants_5_frugs %>%
  filter(Frug_IUCN != "LC")

biome_plants_5_noLC_counts <- biome_plants_5_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(biome_plants_5_noLC_counts$`n()`[which(biome_plants_5_noLC_counts$`n()` == 5)])

```

##### Ecoregion-scale networks: Serra do Mar

How many specialist trees are dispersed by only 1 frugivore in the serra.do.mar network?

```{r how many tree species have degree of 1 in the serra do mar scale network}

serra.do.mar_plants_1 <- interaction_md.SM %>%
  filter(Plant_degree == 1, .keep_all = TRUE)

length(unique(serra.do.mar_plants_1$Plant_Species))

serra.do.mar_plants_1_frugs <- serra.do.mar_plants_1 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

names(serra.do.mar_plants_1_frugs)[3] <-"Frugivore_Species" #rename

```

How many of those are dispersed only by endangered frugivores?

```{r how many trees with degree of 1 and are dispersed only by endangered frugivores in the serra.do.mar scale network}
serra.do.mar_plants_1_noLC <- serra.do.mar_plants_1_frugs %>%
  filter(Frug_IUCN != "LC")

serra.do.mar_plants_1_noLC_counts <- serra.do.mar_plants_1_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

#only the single row occurrences tell me which plant species actually ONLY had endangered frugivores as their disperser
length(serra.do.mar_plants_1_noLC_counts$`n()`[which(serra.do.mar_plants_1_noLC_counts$`n()` == 1)])

```

How many trees are only dispersed by 2 frugivores in the serra.do.mar network? 

```{r how many trees with a degree of 2 exist in the serra.do.mar scale network}

serra.do.mar_plants_2 <- interaction_md.SM %>%
  filter(Plant_degree ==2, .keep_all = TRUE)

length(unique(serra.do.mar_plants_2$Plant_Species))


```

How many tree species with a degree of 2 are dispersed only by endangered frugivores in the serra.do.mar network?

```{r how many trees with degree of 2 are only dispersed by endangered frugivores in the serra.do.mar scale network}

serra.do.mar_plants_2_frugIUCN <- serra.do.mar_plants_2 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

serra.do.mar_plants_2_frugIUCN_noLC <- serra.do.mar_plants_2_frugIUCN %>%
  filter(Frug_IUCN != "LC")

counts <- serra.do.mar_plants_2_frugIUCN_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

# again, going by row number, we are interested in the trees that have only two observations (rows) and of which both of those rows/observations are of interactions with endangered frugivores

length(counts$`n()`[which(counts$`n()` == 2)])

```

How many trees are dispersed by only 3 frugivores in the serra.do.mar network?

```{r how many trees with degree of 3 in the serra.do.mar scale network}

serra.do.mar_plants_3 <- interaction_md.SM %>%
  filter(Plant_degree == 3, .keep_all = TRUE)

length(unique(serra.do.mar_plants_3$Plant_Species))

```

How many of the trees with a degree of 3 are dispersed only by endangered frugivores in the serra.do.mar network?

```{r how many trees with degree of 3 only dispersed by endangered frugivores in the serra.do.mar scale network}

serra.do.mar_plants_3_frugIUCN <- serra.do.mar_plants_3 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

serra.do.mar_plants_3_noLC <- serra.do.mar_plants_3_frugIUCN %>%
  filter(Frug_IUCN != "LC")

serra.do.mar_plants_3_noLC_counts <- serra.do.mar_plants_3_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(serra.do.mar_plants_3_noLC_counts$`n()`[which(serra.do.mar_plants_3_noLC_counts$`n()` == 3)])

```

How many trees are dispersed by 4 frugivores in the serra.do.mar network?

```{r how many trees species have a degree of 4 in the serra.do.mar scale network}

serra.do.mar_plants_4 <- interaction_md.SM %>%
  filter(Plant_degree == 4, .keep_all = TRUE)

length(unique(serra.do.mar_plants_4$Plant_Species))

```
How many of the trees with a degree of 4 are dispersed only by endangered frugivores in the serra.do.mar network?

```{r how many trees with degree of 4 only dispersed by endangered frugs in the serra.do.mar network}

serra.do.mar_plants_4_frugs <- serra.do.mar_plants_4 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

serra.do.mar_plants_4_noLC <- serra.do.mar_plants_4_frugs %>%
  filter(Frug_IUCN != "LC")

serra.do.mar_plants_4_noLC_counts <- serra.do.mar_plants_4_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(serra.do.mar_plants_4_noLC_counts$`n()`[which(serra.do.mar_plants_4_noLC_counts$`n()` == 4)])

```

How many tree species in the serra.do.mar network have a degree of 5?

```{r how many trees with degree of 5 in the serra.do.mar network}

serra.do.mar_plants_5 <- interaction_md.SM %>%
  filter(Plant_degree == 5, .keep_all = TRUE)

length(unique(serra.do.mar_plants_5$Plant_Species))

```

How many tree species with a degree of 5 are dispersed only by endangered frugivores in the serra.do.mar network?

```{r how many trees with degree of 5 are only dispersed by endangered frugivores in the serra.do.mar network}

serra.do.mar_plants_5_frugs <- serra.do.mar_plants_5 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

serra.do.mar_plants_5_noLC <- serra.do.mar_plants_5_frugs %>%
  filter(Frug_IUCN != "LC")

serra.do.mar_plants_5_noLC_counts <- serra.do.mar_plants_5_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(serra.do.mar_plants_5_noLC_counts$`n()`[which(serra.do.mar_plants_5_noLC_counts$`n()` == 5)])

```

##### Ecoregion-scale networks: Cerrado

How many specialist trees are dispersed by only 1 frugivore in the cerrado network?

```{r how many tree species have degree of 1 in the cerrado scale network}

cerrado_plants_1 <- interaction_md.CR %>%
  filter(Plant_degree == 1, .keep_all = TRUE)

length(unique(cerrado_plants_1$Plant_Species))

cerrado_plants_1_frugs <- cerrado_plants_1 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

names(cerrado_plants_1_frugs)[3] <-"Frugivore_Species" #rename

```

How many of those are dispersed only by endangered frugivores?

```{r how many trees with degree of 1 and are dispersed only by endangered frugivores in the cerrado scale network}
cerrado_plants_1_noLC <- cerrado_plants_1_frugs %>%
  filter(Frug_IUCN != "LC")

cerrado_plants_1_noLC_counts <- cerrado_plants_1_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

#only the single row occurrences tell me which plant species actually ONLY had endangered frugivores as their disperser
length(cerrado_plants_1_noLC_counts$`n()`[which(cerrado_plants_1_noLC_counts$`n()` == 1)])

```

How many trees are only dispersed by 2 frugivores in the cerrado network? 

```{r how many trees with a degree of 2 exist in the cerrado scale network}

cerrado_plants_2 <- interaction_md.CR %>%
  filter(Plant_degree ==2, .keep_all = TRUE)

length(unique(cerrado_plants_2$Plant_Species))


```

How many tree species with a degree of 2 are dispersed only by endangered frugivores in the cerrado network?

```{r how many trees with degree of 2 are only dispersed by endangered frugivores in the cerrado scale network}

cerrado_plants_2_frugIUCN <- cerrado_plants_2 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

cerrado_plants_2_frugIUCN_noLC <- cerrado_plants_2_frugIUCN %>%
  filter(Frug_IUCN != "LC")

counts <- cerrado_plants_2_frugIUCN_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

# again, going by row number, we are interested in the trees that have only two observations (rows) and of which both of those rows/observations are of interactions with endangered frugivores

length(counts$`n()`[which(counts$`n()` == 2)])

```

How many trees are dispersed by only 3 frugivores in the cerrado network?

```{r how many trees with degree of 3 in the cerrado scale network}

cerrado_plants_3 <- interaction_md.CR %>%
  filter(Plant_degree == 3, .keep_all = TRUE)

length(unique(cerrado_plants_3$Plant_Species))

```

Zero trees in the cerrado ecoregion network have degree = 3.


How many trees are dispersed by 4 frugivores in the cerrado network?

```{r how many trees species have a degree of 4 in the cerrado scale network}

cerrado_plants_4 <- interaction_md.CR %>%
  filter(Plant_degree == 4, .keep_all = TRUE)

length(unique(cerrado_plants_4$Plant_Species))

```
Zero trees in the cerrado ecoregion network have degree = 4.


How many tree species in the cerrado network have a degree of 5?

```{r how many trees with degree of 5 in the cerrado network}

cerrado_plants_5 <- interaction_md.CR %>%
  filter(Plant_degree == 5, .keep_all = TRUE)

length(unique(cerrado_plants_5$Plant_Species))

```

Zero trees in the cerrado ecoregion network have degree = 5.


##### Ecoregion-scale networks: Mata Caducifolia

How many specialist trees are dispersed by only 1 frugivore in the mata.caducifolia network?

```{r how many tree species have degree of 1 in the mata caducifolia scale network}

mata.caducifolia_plants_1 <- interaction_md.MC %>%
  filter(Plant_degree == 1, .keep_all = TRUE)

length(unique(mata.caducifolia_plants_1$Plant_Species))

mata.caducifolia_plants_1_frugs <- mata.caducifolia_plants_1 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

names(mata.caducifolia_plants_1_frugs)[3] <-"Frugivore_Species" #rename

```

How many of those are dispersed only by endangered frugivores?

```{r how many trees with degree of 1 and are dispersed only by endangered frugivores in the mata.caducifolia scale network, message=FALSE}
mata.caducifolia_plants_1_noLC <- mata.caducifolia_plants_1_frugs %>%
  filter(Frug_IUCN != "LC")

mata.caducifolia_plants_1_noLC_counts <- mata.caducifolia_plants_1_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

#only the single row occurrences tell me which plant species actually ONLY had endangered frugivores as their disperser
length(mata.caducifolia_plants_1_noLC_counts$`n()`[which(mata.caducifolia_plants_1_noLC_counts$`n()` == 1)])

```

How many trees are only dispersed by 2 frugivores in the mata.caducifolia network? 

```{r how many trees with a degree of 2 exist in the mata.caducifolia scale network}

mata.caducifolia_plants_2 <- interaction_md.MC %>%
  filter(Plant_degree ==2, .keep_all = TRUE)

length(unique(mata.caducifolia_plants_2$Plant_Species))


```

How many tree species with a degree of 2 are dispersed only by endangered frugivores in the mata.caducifolia network?

```{r how many trees with degree of 2 are only dispersed by endangered frugivores in the mata.caducifolia scale network, message=FALSE}

mata.caducifolia_plants_2_frugIUCN <- mata.caducifolia_plants_2 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

mata.caducifolia_plants_2_frugIUCN_noLC <- mata.caducifolia_plants_2_frugIUCN %>%
  filter(Frug_IUCN != "LC")

counts <- mata.caducifolia_plants_2_frugIUCN_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

# again, going by row number, we are interested in the trees that have only two observations (rows) and of which both of those rows/observations are of interactions with endangered frugivores

length(counts$`n()`[which(counts$`n()` == 2)])

```

How many trees are dispersed by only 3 frugivores in the mata.caducifolia network?

```{r how many trees with degree of 3 in the mata.caducifolia scale network}

mata.caducifolia_plants_3 <- interaction_md.MC %>%
  filter(Plant_degree == 3, .keep_all = TRUE)

length(unique(mata.caducifolia_plants_3$Plant_Species))

```

How many of the trees with a degree of 3 are dispersed only by endangered frugivores in the mata.caducifolia network?

```{r how many trees with degree of 3 only dispersed by endangered frugivores in the mata.caducifolia scale network, message=FALSE}

mata.caducifolia_plants_3_frugIUCN <- mata.caducifolia_plants_3 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

mata.caducifolia_plants_3_noLC <- mata.caducifolia_plants_3_frugIUCN %>%
  filter(Frug_IUCN != "LC")

mata.caducifolia_plants_3_noLC_counts <- mata.caducifolia_plants_3_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(mata.caducifolia_plants_3_noLC_counts$`n()`[which(mata.caducifolia_plants_3_noLC_counts$`n()` == 3)])

```

How many trees are dispersed by 4 frugivores in the mata.caducifolia network?

```{r how many trees species have a degree of 4 in the mata.caducifolia scale network}

mata.caducifolia_plants_4 <- interaction_md.MC %>%
  filter(Plant_degree == 4, .keep_all = TRUE)

length(unique(mata.caducifolia_plants_4$Plant_Species))

```
How many of the trees with a degree of 4 are dispersed only by endangered frugivores in the mata.caducifolia network?

```{r how many trees with degree of 4 only dispersed by endangered frugs in the mata.caducifolia network, message=FALSE}

mata.caducifolia_plants_4_frugs <- mata.caducifolia_plants_4 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

mata.caducifolia_plants_4_noLC <- mata.caducifolia_plants_4_frugs %>%
  filter(Frug_IUCN != "LC")

mata.caducifolia_plants_4_noLC_counts <- mata.caducifolia_plants_4_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(mata.caducifolia_plants_4_noLC_counts$`n()`[which(mata.caducifolia_plants_4_noLC_counts$`n()` == 4)])

```

How many tree species in the mata.caducifolia network have a degree of 5?

```{r how many trees with degree of 5 in the mata.caducifolia network}

mata.caducifolia_plants_5 <- interaction_md.MC %>%
  filter(Plant_degree == 5, .keep_all = TRUE)

length(unique(mata.caducifolia_plants_5$Plant_Species))

```

How many tree species with a degree of 5 are dispersed only by endangered frugivores in the mata.caducifolia network?

```{r how many trees with degree of 5 are only dispersed by endangered frugivores in the mata.caducifolia network, message=FALSE}

mata.caducifolia_plants_5_frugs <- mata.caducifolia_plants_5 %>%
  group_by(Plant_Species, Frug_IUCN) %>%
  summarise(unique(Frugivore_Species))

mata.caducifolia_plants_5_noLC <- mata.caducifolia_plants_5_frugs %>%
  filter(Frug_IUCN != "LC")

mata.caducifolia_plants_5_noLC_counts <- mata.caducifolia_plants_5_noLC %>%
  group_by(Plant_Species) %>%
  summarise(n())

length(mata.caducifolia_plants_5_noLC_counts$`n()`[which(mata.caducifolia_plants_5_noLC_counts$`n()` == 5)])

```


### Model testing associations between plant degree and frugivore endangerment levels

Berry approach 16 May 2022

**we want to know if specialist trees (those visited only by one frugivore) are more likely to be visited by an endangered frugivore than chance alone would predict**

* percentage of specialist plants visited by endangered frugivores is 156/285 = 54.7%
* yet only ~17% of frugivores are endangered
* Thinking through the model options:
    + you could set this up as plants on rows (degree == 1 / specialists vs. not) and frugivores on the columns (endangered vs. not) and you could run that model, but that is asking if the proportions of endangered frugivores are different among endangered vs. non-endangered plants; that is a different question (and one that would require a binomial-errors GLMM due to pseudoreplication among plant and frugivore species)
    
There are a couple of ways we could get at the question above:

* generate binomial confidence intervals for the proportion of endangered frugivores visiting specialist trees (~54%); then compare to the proportion of endangered frugivores in the system (~17%)
    + if the proportion visiting specialist trees is larger than the proportion in the system, and the latter is outside of the confidence intervals of the former, then we would say it is significantly higher proportion than we would expect by chance alone
    + could also do this with generating confidence intervals for both estimates (not just prop. endangered frugivores visiting specialists, but also prop endangered frugivores overall)
    + easy to do using the `binom` package for R, with the function `binom.confint`
    + **DID THIS** and they don't even come close to overlapping
* alternatively, we could take the same philosophical approach as above but conduct the analysis a little more formally ($p$-value and all) via a permutation test
    + build a null distribution of expected values of proportion of endangered frugivores visiting specialist trees (based on the proportion of endangered frugivores overall); then compare the observed value to that distribution. If the observed value is greater than the top 5% of values (this is *a priori* a one-tailed test), then the proportion of endangered frugivores visiting specialist plants is significantly greater than we would expect by chance alone. The rank of the observed value in the null distribution is its $p$-value.
    + this approach also gives the potential to explore other options (other null models). The other one that comes to mind is to not just base the null model on the *proportion* of endangered frugivores, but instead to *weight* the null model based on frugivore degree; frugivores with higher degree are more likely to be the one frugivore connecting with an endangered plant. Because we have previously shown in this analysis that endangered frugivores are more likely to have a higher degree, this is likely a more conservative test than the simpler null model above.
    + in the code below, I took the latter approach (basing it on the number of which results in a more conservative test
    + for both, run 9,999 permutations to get a reasonable precision associated with the $p$-value

```{r model specialist trees frugivore endangerment}

# start by defining yes / no variables for tree specialists 
# and endangered frugivores:

# get focal data
# specgendat = "specialist / generalist data"
specgendat <- biome_interaction_md
# create new variable called "specialists", set base value = 0
specgendat$specialists = 0
# for those plants that only interact with one frugivore, change value = 1
specgendat$specialists[specgendat$Plant_degree==1] = 1

# create new variable called "endangered" (frugivores), set base value = 1
specgendat$endangered = 1
# for those frugivores that are "LC" (least concern), change value = 0
specgendat$endangered[specgendat$Frug_IUCN=="LC"] = 0

#=====================

# quick checks:
# what is the proportion of endangered frugivores?
frugs = specgendat %>% group_by(Frugivore_Species) %>% 
  summarize(endangered = mean(endangered))
prop.endangered = sum(frugs$endangered)/nrow(frugs)
# 13.7% of frugivores endangered (44/321)

# proportion of interactions driven by endangered frugivores:
prop.endang.int = sum(specgendat$endangered)/nrow(specgendat)
# 17.2% of interactions are by endangered frugivores

# what is the proportion of specialist trees?
# (not really all that relevant)
specs = specgendat %>% group_by(Plant_Species) %>% 
  summarize(specialists = mean(specialists)) 
prop.spec = sum(specs$specialists)/nrow(specs)
# 36.7% of trees are specialists (285/777)

# what is proportion of specialist trees visited by endangered frugs?
spec.ends = specgendat %>% filter(specialists == 1) %>% group_by(Plant_Species) %>% 
  summarize(spec.ends = mean(endangered))
prop.spec.ends = sum(spec.ends$spec.ends)/nrow(spec.ends)
# 54.7% of specialist plants are visited by endangered frugivores (156/285)

#=====================
# binomial confidence intervals

library(binom)
# CIs for prop specialist trees visited by endangered frugivores:
spec.end.confint = binom.confint(sum(spec.ends$spec.ends), nrow(spec.ends), 
                                 method = "agresti")
# CIs for prop of endangered frugivores:
frug.end.confint = binom.confint(sum(frugs$endangered), nrow(frugs), 
                                 method = "agresti")
# rbind CI tables:
spec.end.confint = rbind(spec.end.confint, frug.end.confint)
spec.end.confint[,1] = c("specialists.endangered", "frugivores.endangered")

# clear that CIs do not overlap: upper CI for frugivore endangerment is 17.9%;
# lower CI for prop endangered frugivores interacting w/specialist plants is 48.9%

```

#### null models of specialist trees frugivore endangerment

basic idea:

* `for` loop with 9999? iterations
* sample without replacement the set `specgendat$endangered` to the length of the set of specialist plants `sum(specgendat$specialists)` (= `r sum(specgendat$specialists)`)
    + in other words, sampling the entire set of observed interactions, not the set of frugivores
    + this is more conservative since we know that endangered frugivores trend toward having higher degrees (number of interaction partners) than  non-endangered
    + this is reflected in the fact that `r prop.endang.int` of interactions are carried out by endangered frugivores, whereas `r prop.endangered` of frugivores are endangered 
* calculate (and store) the proportion of endangered frugivores in that vector (sum of vector / length of vector)
* find the rank of the observed value (`r prop.spec.ends`) within the set above; $p$-value is the inverse of the rank (1/rank); if in the top 5% of values the $p$-value will be < 0.05 and thus statistically significant
    + this is a one-tailed test as we have the *a priori* hypothesis that we are seeing a *higher* number of interactions of specialist plants with endangered frugivores than we would expect by chance
    + the precision of the $p$-value is driven by the number of permutations: 99 perms = precision of 2 digits (e.g. smallest possible $p$-val = 0.01); 999 = 3 digits or a minimum of 0.001; etc.

```{r null model specialist trees frugivore endangerment}

nreps = 9999

# create vector to store results in
results = rep(NA, nreps)

for(i in 1:nreps){
  temp = sample(specgendat$endangered, sum(specgendat$specialists))
  results[i] = sum(temp)/length(temp)
}

# calculate p-value (reciprocal of rank of observed in set of obs. + simulated)
pval = 1/rank(c(prop.spec.ends, results))[1]
# display p-value
paste("p =", (format(pval, scientific = F)))
# graph
# hist(results)
```

While as with any permutation test, results may vary from run to run, every time I tried I got the minimum possible $p$-value, i.e. $p = 0.0001$. This indicates that specialist plants are interacting much more with endangered frugivores than we would expect by chance, if endangered frugivores were visiting plants at random; the difference is strongly statistically significant.


# Session Info and Package Loading Messages


```{r Session Info}
sessionInfo()
```